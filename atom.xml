<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT草根</title>
  <subtitle>WangXu&#39;s 代码馆 BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codepub.cn/"/>
  <updated>2017-12-12T14:36:49.957Z</updated>
  <id>http://www.codepub.cn/</id>
  
  <author>
    <name>Wang Xu</name>
    <email>wangx89@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lucene 近实时搜索</title>
    <link href="http://www.codepub.cn/2017/12/12/lucene-near-real-time-search/"/>
    <id>http://www.codepub.cn/2017/12/12/lucene-near-real-time-search/</id>
    <published>2017-12-12T14:35:56.000Z</published>
    <updated>2017-12-12T14:36:49.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lucene-事务"><a href="#Lucene-事务" class="headerlink" title="Lucene 事务"></a>Lucene 事务</h3><p>有过数据库经验的人都知道ACID特性，原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。由于隔离性的存在，对于新的变更包括添加、修改、删除，如果不进行 commit 的话，那么在读端是无法看到数据的变化的，在这里简单的介绍下 Lucene 中的事务，即ACID。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>当你在一次 IndexWriter 的 session 中做操作（增加，删除文档），然后 commit，要么你的所有的操作修改都是可见的（commit 成功），要么所有的操作修改都不可见（commit 失败），绝不会处于某种中间状态。有些方法有它自身的原子操作：如果你调用 updateDocument 方法，其内在实现是先删除后添加文档，即使你打开了一个近实时（NRT）reader 或者使用另一个线程做 commit，绝不会出现只有删除而没有添加的情况。与此类似，如果使用 addDocuments 方法添加一组文档，对于任何 reader 而言，要么所有的文档可见，要么所有文档不可见。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>如果计算机或者 OS 崩溃，或者 JVM 挂掉或被杀死，亦或是电源被拔掉了，你的索引都会保持完好。注意，像 RAM 故障，CPU 位翻转或者文件系统损坏之类的问题，还是容易造成索引破坏的。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>当 IndexWriter 正在做更改的时候，所有更改都不会对当前搜索该索引的 IndexReader 可见，直到你 commit 或者打开了一个新的 NRT reader。一次只能有一个 IndexWriter 实例对索引进行更改。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>一旦 commit 操作返回，所有变更都会被写入到持久化存储。如果计算机或者 OS 崩溃，或者 JVM 挂掉或被杀死，亦或是电源被拔掉了，所有的变更都已在索引中保存。</p>
<h3 id="Lucene-近实时搜索"><a href="#Lucene-近实时搜索" class="headerlink" title="Lucene 近实时搜索"></a>Lucene 近实时搜索</h3><p>如果对数据没有实时性的要求，那么完全不用关心 Lucene 的近实时搜索。但是由于隔离性的存在，我们知道，对于新的数据，如果写端不 commit 的话，那么搜索端则是不可见的；还有另外一种情况，就是在搜索端可以持有 IndexWriter 的情况下，利用 IndexWriter 打开 reader，则可以保证 reader 能够看到最新的数据，包括还未提交的数据。同样一旦 reader 打开索引之后，对于写端新的未提交数据同样不可见。</p>
<p>除此之外 Lucene 与数据库还稍有不同，就是 Lucene 使用 IndexReader 打开索引的时候，相当于是对当前索引做了一次快照（Snapshot），即便写端进行了 commit 操作，如果 IndexReader 不重新打开的话，新提交的内容对搜索端依然是不可见的。那么要实现 Lucene 的近实时搜索，关键有两个方面，一是写端定期进行 commit 操作，二是搜索端定期进行 reopen 操作。</p>
<h4 id="搜索端持有-IndexWriter"><a href="#搜索端持有-IndexWriter" class="headerlink" title="搜索端持有 IndexWriter"></a>搜索端持有 IndexWriter</h4><p>对于大规模的搜索应用，一般都是读写分离的，而且由于 Lucene 在同一时刻，仅允许有一个写端存在，但可以有多个读端同时存在，所以这种架构在生产环境其实很少使用，因为所有的读端基本上都是和写端隔离甚至分别部署在不同的应用之中，不过这个知识在某些场景依然很有用，同时了解这个知识可以帮助你更加深入的理解 Lucene。</p>
<h5 id="由自己负责重新打开"><a href="#由自己负责重新打开" class="headerlink" title="由自己负责重新打开"></a>由自己负责重新打开</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.MatchAllDocsQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearRealTimeSearchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                <span class="comment">//即便没有commit，依然能看到Doc1</span></div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">            <span class="comment">//即便后来commit了，依然无法看到Doc2，因为没有重新打开IndexSearcher</span></div><div class="line">            System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        indexSearcher.getIndexReader().close();</div><div class="line">        indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">        count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">            <span class="comment">//重新打开IndexSearcher，可以看到Doc1和Doc2</span></div><div class="line">            System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">=================================</div></pre></td></tr></table></figure></p>
<h5 id="使用ControlledRealTimeReopenThread定时重新打开"><a href="#使用ControlledRealTimeReopenThread定时重新打开" class="headerlink" title="使用ControlledRealTimeReopenThread定时重新打开"></a>使用ControlledRealTimeReopenThread定时重新打开</h5><p>Lucene 提供了 ControlledRealTimeReopenThread 线程工具类来负责周期性的打开 ReferenceManager（调用ReferenceManager.maybeRefresh）。该线程类控制打开间隔比较灵活，当有外部用户在等待指定的 generation 时就按最小时间间隔等待，如果没有用户着急获取最新的Searcher，则等待最大时间间隔后再打开。其构造函数如下：</p>
<p>ControlledRealTimeReopenThread(TrackingIndexWriter writer, ReferenceManager<t> manager,<br>double targetMaxStaleSec, double targetMinStaleSec)//单位秒</t></p>
<p>如何判断是否有人等待？</p>
<p>在调用 addDocument 的时候，IndexWriter 为每次更新索引的操作赋予一个标记（generation，代数），递增变化。用户使用 ControlledRealTimeReopenThread.waitForGeneration 告诉其期望获得更新代数，ControlledRealTimeReopenThread 记录了当前已打开的代数，当期望更新代数大于已打开代数时，就表示有用户期望获得最新的 Searcher。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearRealTimeSearchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        SearcherManager searcherManager = <span class="keyword">new</span> SearcherManager(indexWriter, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">//当没有调用者等待指定的generation的时候，必须要重新打开时间间隔5s，言外之意，如果有调用者在等待指定的generation，则只需等0.25s</span></div><div class="line">        <span class="comment">//防止不断的重新打开，严重消耗系统性能，设置最小重新打开时间间隔0.25s</span></div><div class="line">        ControlledRealTimeReopenThread&lt;IndexSearcher&gt; controlledRealTimeReopenThread = <span class="keyword">new</span> ControlledRealTimeReopenThread&lt;&gt;(indexWriter,</div><div class="line">                searcherManager, <span class="number">5</span>, <span class="number">0.25</span>);</div><div class="line">        <span class="comment">//设置为后台线程</span></div><div class="line">        controlledRealTimeReopenThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">        controlledRealTimeReopenThread.setName(<span class="string">"controlled reopen thread"</span>);</div><div class="line">        controlledRealTimeReopenThread.start();</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        IndexSearcher indexSearcher = searcherManager.acquire();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//只能看到Doc1</span></div><div class="line">            count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">                <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                    System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"================================="</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            searcherManager.release(indexSearcher);</div><div class="line">        &#125;</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">6</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//休息6s之后，即使没有commit，依然可以搜索到Doc2，因为ControlledRealTimeReopenThread会刷新SearchManager</span></div><div class="line">        indexSearcher = searcherManager.acquire();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">                <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                    System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"================================="</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            searcherManager.release(indexSearcher);</div><div class="line">        &#125;</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc3"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">3</span>));</div><div class="line">        <span class="keyword">long</span> generation = indexWriter.addDocument(document);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//当有调用者等待某个generation的时候，只需要0.25s即可重新打开</span></div><div class="line">            controlledRealTimeReopenThread.waitForGeneration(generation);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        indexSearcher = searcherManager.acquire();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">                <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                    System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"================================="</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            searcherManager.release(indexSearcher);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc3&gt;&gt;</div><div class="line">=================================</div></pre></td></tr></table></figure></p>
<h4 id="搜索端不持有-IndexWriter"><a href="#搜索端不持有-IndexWriter" class="headerlink" title="搜索端不持有 IndexWriter"></a>搜索端不持有 IndexWriter</h4><p>在实际的工作中，这种模式才是最常见的现象，由于索引可以有多个用户同时搜索，那么只要每一个搜索端都不持有 IndexWriter，就可以实现一个简单的分布式搜索服务。由前面所知，这种情况下，只有当写端进行 commit 操作之后，搜索端重新打开 reader 才能搜索到最新的数据。</p>
<h5 id="使用DirectoryReader刷新"><a href="#使用DirectoryReader刷新" class="headerlink" title="使用DirectoryReader刷新"></a>使用DirectoryReader刷新</h5><p>在示例代码中虽然 IndexWriter 和 IndexSearcher 写在同一个类中，但是我们并不从 IndexWriter 打开索引，而是通过 Directory 打开索引，这里仅是简单示例，所以实际开发中，这个类中完全没有 IndexWriter 也是可以的。</p>
<p>想要看到新的结果就需要重新打开一个 IndexReader，DirectoryReader 提供了 openIfChanged(DirectoryReader oldReader) 函数，只有索引有变化时才返回新的 reader（不是完全打开一个 new reader，会复用 old reader 的一些资源，并入新索引，降低一些开销）， 否则返回 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.MatchAllDocsQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearRealTimeSearchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        DirectoryReader directoryReader = DirectoryReader.open(ramDirectory);</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(directoryReader);</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        <span class="comment">//即使commit，搜索依然不可见，需要重新打开reader</span></div><div class="line">        indexWriter.commit();</div><div class="line">        <span class="comment">//只能看到Doc1</span></div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        <span class="comment">//如果发现有新数据更新，则会返回一个新的reader</span></div><div class="line">        DirectoryReader newReader = DirectoryReader.openIfChanged(directoryReader);</div><div class="line">        <span class="keyword">if</span> (newReader != <span class="keyword">null</span>) &#123;</div><div class="line">            indexSearcher = <span class="keyword">new</span> IndexSearcher(newReader);</div><div class="line">            directoryReader.close();</div><div class="line">        &#125;</div><div class="line">        count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">=================================</div></pre></td></tr></table></figure></p>
<h5 id="使用SearcherManager刷新"><a href="#使用SearcherManager刷新" class="headerlink" title="使用SearcherManager刷新"></a>使用SearcherManager刷新</h5><p>在实际应用中，会并行的进行搜索、建索引、打开新 reader、关闭老 reader，操作比较复杂还有线程安全问题。为了简化使用流程，Lucene 提供了 SearcherManager extends ReferenceManager<indexsearcher> 管理 IndexReader 的重建和关闭，保证了线程安全，封装了 IndexSearcher 的生成。</indexsearcher></p>
<p>SearcherManager的主要职责如下，主要提供如下三个接口</p>
<ul>
<li>acquire：获取当前已打开的最新 IndexSearcher，同时将对应的 IndexReader 引用计数加1</li>
<li>release：释放之前通过 acquire 方法获取的引用，本质调的是 <code>IndexSearcher.getIndexReader().decRef();</code>，当一个 IndexReader 的引用计数为0时，会将之关闭同时释放其持有的资源</li>
<li>maybeRefresh：尝试打开新的 IndexReader，本质调用的是 DirectoryReader.openIfChanged() 方法，如果多个线程同时调用该方法，那么只有第一个线程会去尝试刷新，后来的或者说随后的线程看到有其它线程在处理刷新，那么会立即返回；注意这意味着，如果有一个线程在处理刷新操作，那么后续的线程会立即返回而不是等待它刷新完成，所以后续调用该方法的线程可能是已经刷新了的或者是没有任何改变的（没有任何改变意味着通过 acquire 获取的 IndexSearcher 无法搜索到最新的数据）</li>
<li>maybeRefreshBlocking：功能同 maybeRefresh()，但是不像 maybeRefresh()，如果有一个线程正在刷新，后续的线程将阻塞，直到前面的线程刷新完成，然后后续的线程再继续刷新；这非常有用对于想要保证下一次 acquire() 的调用将返回一个刷新的实例，否则考虑使用 maybeRefresh()</li>
</ul>
<p>SearcherManager 的一个注意点是，如果调用了 acquire，那么一定要调用 release，在该方法内部会通过 IndexSearcher 获取IndexReader，然后将 IndexReader 的引用计数减1，当这个引用计数为0的时候，这个 IndexReader 就会被关闭，从而可以释放资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearRealTimeSearchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        SearcherManager searcherManager = <span class="keyword">new</span> SearcherManager(ramDirectory, <span class="keyword">null</span>);</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        <span class="comment">//即使commit，搜索依然不可见，需要重新打开reader</span></div><div class="line">        indexWriter.commit();</div><div class="line">        <span class="comment">//只能看到Doc1</span></div><div class="line">        IndexSearcher indexSearcher = searcherManager.acquire();</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        <span class="comment">//最好放到finally语句块中</span></div><div class="line">        searcherManager.release(indexSearcher);</div><div class="line">        <span class="keyword">if</span> (!searcherManager.isSearcherCurrent()) &#123;</div><div class="line">            <span class="comment">//说明有新数据，需要刷新</span></div><div class="line">            searcherManager.maybeRefresh();</div><div class="line">        &#125;</div><div class="line">        indexSearcher = searcherManager.acquire();</div><div class="line">        count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        searcherManager.release(indexSearcher);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">=================================</div></pre></td></tr></table></figure></p>
<h5 id="使用定时线程执行刷新"><a href="#使用定时线程执行刷新" class="headerlink" title="使用定时线程执行刷新"></a>使用定时线程执行刷新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NearRealTimeSearchDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SearcherManager searcherManager;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</div><div class="line">        executorService.scheduleWithFixedDelay(<span class="keyword">new</span> RefreshThread(), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        searcherManager = <span class="keyword">new</span> SearcherManager(ramDirectory, <span class="keyword">null</span>);</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        <span class="comment">//即使commit，搜索依然不可见，需要重新打开reader</span></div><div class="line">        indexWriter.commit();</div><div class="line">        <span class="comment">//只能看到Doc1</span></div><div class="line">        IndexSearcher indexSearcher = searcherManager.acquire();</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        <span class="comment">//最好放到finally语句块中</span></div><div class="line">        searcherManager.release(indexSearcher);</div><div class="line">        <span class="comment">//休息2s中，定时线程应该已经刷新了</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        indexSearcher = searcherManager.acquire();</div><div class="line">        count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            TopDocs topDocs = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">            <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</div><div class="line">                System.out.println(indexSearcher.doc(scoreDoc.doc));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"================================="</span>);</div><div class="line">        searcherManager.release(indexSearcher);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                searcherManager.maybeRefresh();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">=================================</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc1&gt;&gt;</div><div class="line">Document&lt;stored,indexed,tokenized&lt;title:Doc2&gt;&gt;</div><div class="line">=================================</div></pre></td></tr></table></figure>
<h3 id="SearcherLifetimeManager管理Search-Session"><a href="#SearcherLifetimeManager管理Search-Session" class="headerlink" title="SearcherLifetimeManager管理Search Session"></a>SearcherLifetimeManager管理Search Session</h3><p>管理 IndexSearcher 的生命周期主要是用在分页的时候，例如如果不进行管理的话，那么在用户提交了更改到索引中，正好此时后台线程开始刷新 IndexSearcher，如果提交的内容和用户的搜索不相关的话还好，如果提交的内容是和用户搜索结果相关的，那么新增加的内容可能会影响结果排序，从而在分页的时候可能会使用户点击翻页却看到相同的内容。</p>
<p>为了保证一个良好的用户体验，需要对用户在一个搜索会话期间分页的时候使用同样一个 IndexSearcher，这样在分页期间，可以保证搜索结果的排序是稳定不变的，从而用户也不会再次看到同样的内容。SearcherLifetimeManager 主要有如下几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IndexSearcher <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> version)</span> <span class="comment">//根据version获取之前记录的IndexSearcher，引用计数加1</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(IndexSearcher s)</span> <span class="comment">//释放之前通过acquire获取的IndexSearcher，引用计数减1</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">record</span><span class="params">(IndexSearcher searcher)</span> <span class="comment">//把当前正在使用的IndexSearcher放入内部的ConcurrentHashMap，并返回一个token，之后可以通过该token再次获取该IndexSearcher</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">prune</span><span class="params">(Pruner pruner)</span> <span class="comment">//按指示的age关闭IndexSearcher，并将它们从ConcurrentHashMap中移除</span></div></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntPoint;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.SearcherLifetimeManager;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearcherLifetimeManagerDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SearcherLifetimeManager searcherLifetimeManager = <span class="keyword">new</span> SearcherLifetimeManager();</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc1"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">1</span>));</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> TextField(<span class="string">"title"</span>, <span class="string">"Doc2"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> IntPoint(<span class="string">"ID"</span>, <span class="number">2</span>));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.commit();</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        <span class="comment">//记录当前的searcher，保存token，当有后续的搜索请求到来，例如用户翻页，那么用这个token去获取对应的那个searcher</span></div><div class="line">        <span class="keyword">long</span> record = searcherLifetimeManager.record(indexSearcher);</div><div class="line">        indexSearcher = searcherLifetimeManager.acquire(record);</div><div class="line">        <span class="keyword">if</span> (indexSearcher != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Searcher is still here</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// do searching...</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                searcherLifetimeManager.release(indexSearcher);</div><div class="line">                <span class="comment">// Do not use searcher after this!</span></div><div class="line">                indexSearcher = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Searcher was pruned -- notify user session timed out, or, pull fresh searcher again</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//由于保留许多的searcher是非常耗系统资源的，包括打开发files和RAM，所以最好在一个单独的线程中，定期的重新打开searcher和定时的去清理旧的searcher</span></div><div class="line">        <span class="comment">//丢弃所有比指定的时间都老的searcher</span></div><div class="line">        searcherLifetimeManager.prune(<span class="keyword">new</span> SearcherLifetimeManager.PruneByAge(<span class="number">600.0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Notes</strong>：本文代码基于 Lucene 7.0.0 开发</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lucene-事务&quot;&gt;&lt;a href=&quot;#Lucene-事务&quot; class=&quot;headerlink&quot; title=&quot;Lucene 事务&quot;&gt;&lt;/a&gt;Lucene 事务&lt;/h3&gt;&lt;p&gt;有过数据库经验的人都知道ACID特性，原子性（atomicity，或称不可分割性）、
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 分组统计详解</title>
    <link href="http://www.codepub.cn/2017/11/15/lucene-group-statistics-detailed/"/>
    <id>http://www.codepub.cn/2017/11/15/lucene-group-statistics-detailed/</id>
    <published>2017-11-15T14:43:43.000Z</published>
    <updated>2017-11-20T14:19:15.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>在 RDBMS 中，我们可以使用 GROUP BY 来对检索的数据进行分组，同样地，想要在 Lucene 中实现分组要如何做呢？首先思考如下几个问题</p>
<ul>
<li>Lucene 是如何实现分组的？</li>
<li>用来分组的字段（域）或者说 Field 如何添加？</li>
<li>组的大小如何设置？</li>
<li>组内大小如何设置？</li>
<li>如何实现组的分页？</li>
<li>如果结果集超过了组内大小，可以通过分页解决，那么如果结果集超过了组大小的上限，如何解决？</li>
<li>如何实现单类别分组，即类似SQL中的 GROUP BY A</li>
<li>如何实现多类别分组，即类似SQL中的 GROUP BY A, B</li>
</ul>
<h3 id="从-SQL-的-GROUP-BY-说起"><a href="#从-SQL-的-GROUP-BY-说起" class="headerlink" title="从 SQL 的 GROUP BY 说起"></a>从 SQL 的 GROUP BY 说起</h3><p>如果分组后面只有一个字段，如 GROUP BY A 意思是将所有具有相同A字段值的记录放到一个分组里。那么如果是GROUP BY A, B呢？其意思是将所有具有相同A字段值和B字段值的记录放到一个分组里，在这里A和B之间是逻辑与的关系。</p>
<p>通常的，如果在SQL中，我们仅用 GROUP BY 语句而不加 WHERE 条件的话，那么相当于在全部数据中进行分组，对应于 Lucene 中相当于使用 GROUP 加 new MatchAllDocsQuery() 的功能。</p>
<p>而如果在SQL中，我们不仅用 GROUP BY 还有 WHERE 条件语句，那么相当于在满足 WHERE 条件的记录中进行分组，这种 WHERE 条件在 Lucene 中可以通过构造各种不同的 Query 进行过滤，然后在符合条件的结果中分组。</p>
<h3 id="Lucene-分组"><a href="#Lucene-分组" class="headerlink" title="Lucene 分组"></a>Lucene 分组</h3><p>有关Lucene分组问题，需要有一系列输入参数，<a href="https://lucene.apache.org/core/7_1_0/grouping/index.html" target="_blank" rel="external">官方Doc在此</a>，核心点如下</p>
<ul>
<li>groupField：用来分组的域，在 Lucene 中，这个域只能设置一个，不像 SQL 中可以根据多个列分组。没有该域的文档将被分到一个单独的组里面</li>
<li>groupSort：组间排序方式，用来指定如何对不同的分组进行排序，而不是组内的文档排序，默认值是<code>Sort.RELEVANCE</code></li>
<li>topNGroups：保留多少组，例如10只取前十个分组</li>
<li>groupOffset：指定组偏移量，比如当topNGroups的值是10的时候，groupOffset为3，则意思是返回7个分组，跳过前面3个，在分页时候很有用</li>
<li>withinGroupSort：组内排序方式，默认值是<code>Sort.RELEVANCE</code>，注意和groupSort的区别，不要求和groupSort使用一样的排序方式</li>
<li>maxDocsPerGroup：表示一个组内最多保留多少个文档</li>
<li>withinGroupOffset：每组显示的文档的偏移量</li>
</ul>
<p>分组通常有两个阶段，第一阶段用<code>FirstPassGroupingCollector</code>收集不同的分组，第二阶段用<code>SecondPassGroupingCollector</code>收集这些分组内的文档，如果分组很耗时，建议用<code>CachingCollector</code>类，可以缓存 hits 并在第二阶段快速返回。这种方式让你相当于只运行了一次 query，但是付出的代价是用 RAM 持有所有的 hits。返回的结果集是TopGroups的实例。</p>
<p>Groups是由GroupSelector（抽象类）的实现来定义的，目前支持两种实现方式</p>
<ul>
<li>TermGroupSelector 基于 SortedDocValues 域进行分组</li>
<li>ValueSourceGroupSelector 基于 ValueSource 值进行分组</li>
</ul>
<p>通常不建议直接使用 FirstPassGroupingCollector 和 SecondPassGroupingCollector 来进行分组操作，因为Lucene提供了一个非常简便的封装类 GroupingSearch，目前分组操作还不支持 Sharding。</p>
<p>网上有许多讲解 Lucene 分组的文章，但是讲的都非常浅显，一般都是取 Top N 个分组，这个 N 是一个确定的值，试问如果我要对全部的结果集进行分组统计，而分组数量超过 Top N 的话，那么这种方式统计的结果显然是不准确的，因为它并没有统计全部的数据。还有的是直接把 <code>maxDoc()</code> 函数的值作为 <code>groupLimit</code> 的值，然后对某个分组内的全部文档进行迭代，无法实现组内分页的问题。</p>
<p>所以本文就针对这个问题，不仅解决了组内分页的问题，还解决了组间分页的问题，可以迭代完全的结果集。</p>
<p>另外一个需要注意的问题就是 <code>maxDoc()</code> 可能返回的是 <code>Integer</code> 型的上限，而将其直接作为 groupLimit 传入的话，是会报错的，错误如下</p>
<p>组内大小和组间大小如果设置为Integer.MAX_VALUE报</p>
<blockquote>
<p>Exception in thread “main” java.lang.NegativeArraySizeException</p>
</blockquote>
<p>组内大小和组间大小如果设置为Integer.MAX_VALUE-1报</p>
<blockquote>
<p>Exception in thread “main” java.lang.IllegalArgumentException: maxSize must be &lt;= 2147483630; got: 2147483646</p>
</blockquote>
<p>完整示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">import org.apache.lucene.analysis.core.WhitespaceAnalyzer;</div><div class="line">import org.apache.lucene.document.*;</div><div class="line">import org.apache.lucene.index.DirectoryReader;</div><div class="line">import org.apache.lucene.index.IndexWriter;</div><div class="line">import org.apache.lucene.index.IndexWriterConfig;</div><div class="line">import org.apache.lucene.search.IndexSearcher;</div><div class="line">import org.apache.lucene.store.Directory;</div><div class="line">import org.apache.lucene.store.RAMDirectory;</div><div class="line">import org.apache.lucene.util.BytesRef;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/11/14 16:41.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: 基于 Lucene 7.0.0</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * @author Wang Xu</div><div class="line"> * @version V1.0.0</div><div class="line"> * @since V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line">public class IndexHelper &#123;</div><div class="line">    private Document document;</div><div class="line">    private Directory directory;</div><div class="line">    private IndexWriter indexWriter;</div><div class="line"></div><div class="line">    public Directory getDirectory() &#123;</div><div class="line">        directory = (directory == null) ? new RAMDirectory() : directory;</div><div class="line">        return directory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IndexWriterConfig getConfig() &#123;</div><div class="line">        return new IndexWriterConfig(new WhitespaceAnalyzer());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IndexWriter getIndexWriter() &#123;</div><div class="line">        try &#123;</div><div class="line">            return new IndexWriter(getDirectory(), getConfig());</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IndexSearcher getIndexSearcher() throws IOException &#123;</div><div class="line">        return new IndexSearcher(DirectoryReader.open(getDirectory()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void createIndexForGroup(int ID, String author, String content) &#123;</div><div class="line">        indexWriter = getIndexWriter();</div><div class="line">        document = new Document();</div><div class="line">        //IntPoint默认是不存储的</div><div class="line">        document.add(new IntPoint(&quot;ID&quot;, ID));</div><div class="line">        //如果想要在搜索结果中获取ID的值，需要加上下面语句</div><div class="line">        document.add(new StoredField(&quot;ID&quot;, ID));</div><div class="line">        document.add(new StringField(&quot;author&quot;, author, Field.Store.YES));</div><div class="line">        //需要使用特定的field存储分组，需要排序及分组的话，要加上下面语句，注意默认SortedDocValuesField也是不存储的</div><div class="line">        document.add(new SortedDocValuesField(&quot;author&quot;, new BytesRef(author)));</div><div class="line">        document.add(new StringField(&quot;content&quot;, content, Field.Store.YES));</div><div class="line">        try &#123;</div><div class="line">            indexWriter.addDocument(document);</div><div class="line">            indexWriter.commit();</div><div class="line">            indexWriter.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.grouping.GroupDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.grouping.GroupingSearch;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.grouping.TopGroups;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.util.BytesRef;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/11/14 16:21.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: 基于 Lucene 7.0.0 开发</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupingDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        IndexHelper indexHelper = <span class="keyword">new</span> IndexHelper();</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">1</span>, <span class="string">"Java"</span>, <span class="string">"一周精通Java"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">2</span>, <span class="string">"Java"</span>, <span class="string">"一周精通MyBatis"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">3</span>, <span class="string">"Java"</span>, <span class="string">"一周精通Struts"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">4</span>, <span class="string">"Java"</span>, <span class="string">"一周精通Spring"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">5</span>, <span class="string">"Java"</span>, <span class="string">"一周精通Spring Cloud"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">6</span>, <span class="string">"Java"</span>, <span class="string">"一周精通Hibernate"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">7</span>, <span class="string">"Java"</span>, <span class="string">"一周精通JVM"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">8</span>, <span class="string">"C"</span>, <span class="string">"一周精通C"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">9</span>, <span class="string">"C"</span>, <span class="string">"C语言详解"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">10</span>, <span class="string">"C"</span>, <span class="string">"C语言调优"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">11</span>, <span class="string">"C++"</span>, <span class="string">"一周精通C++"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">12</span>, <span class="string">"C++"</span>, <span class="string">"C++语言详解"</span>);</div><div class="line">        indexHelper.createIndexForGroup(<span class="number">13</span>, <span class="string">"C++"</span>, <span class="string">"C++语言调优"</span>);</div><div class="line"></div><div class="line">        IndexSearcher indexSearcher = indexHelper.getIndexSearcher();</div><div class="line">        GroupingDemo groupingDemo = <span class="keyword">new</span> GroupingDemo();</div><div class="line">        <span class="comment">//把所有的文档都查出来，由添加的数据可以知道，一共有三组，Java组有7个文档，C和C++组分别都有3个文档</span></div><div class="line">        <span class="comment">//当然了如果做全匹配的话，还可以用new MatchAllDocsQuery()</span></div><div class="line">        BooleanQuery query = <span class="keyword">new</span> BooleanQuery.Builder().add(<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"author"</span>, <span class="string">"Java"</span>)), BooleanClause.Occur.SHOULD).add(<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term</div><div class="line">                        (<span class="string">"author"</span>, <span class="string">"C"</span>)),</div><div class="line">                BooleanClause.Occur.SHOULD).add(<span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"author"</span>, <span class="string">"C++"</span>)), BooleanClause.Occur.SHOULD).build();</div><div class="line">        <span class="comment">//控制每次返回几组</span></div><div class="line">        <span class="keyword">int</span> groupLimit = <span class="number">2</span>;</div><div class="line">        <span class="comment">//控制每一页的组内文档数</span></div><div class="line">        <span class="keyword">int</span> groupDocsLimit = <span class="number">2</span>;</div><div class="line">        <span class="comment">//控制组的偏移</span></div><div class="line">        <span class="keyword">int</span> groupOffset = <span class="number">0</span>;</div><div class="line">        <span class="comment">//为了排除干扰因素，全部使用默认的排序方式，当然你还可以使用自己喜欢的排序方式</span></div><div class="line">        <span class="comment">//初始值为命中的所有文档数，即最坏情况下，一个文档分成一组，那么文档数就是分组的总数</span></div><div class="line">        <span class="keyword">int</span> totalGroupCount = indexSearcher.count(query);</div><div class="line">        TopGroups&lt;BytesRef&gt; topGroups;</div><div class="line">        System.out.println(<span class="string">"#### 组的分页大小为："</span> + groupLimit);</div><div class="line">        System.out.println(<span class="string">"#### 组内分页大小为："</span> + groupDocsLimit);</div><div class="line">        <span class="keyword">while</span> (groupOffset &lt; totalGroupCount) &#123;<span class="comment">//说明还有不同的分组</span></div><div class="line">            <span class="comment">//控制组内偏移，每次开始遍历一个新的分组时候，需要将其归零</span></div><div class="line">            <span class="keyword">int</span> groupDocsOffset = <span class="number">0</span>;</div><div class="line">            System.out.println(<span class="string">"#### 开始组的分页"</span>);</div><div class="line">            topGroups = groupingDemo.group(indexSearcher, query, <span class="string">"author"</span>, groupDocsOffset, groupDocsLimit, groupOffset, groupLimit);</div><div class="line">            <span class="comment">//具体搜了一次之后，就知道到底有多少组了，更新totalGroupCount为正确的值</span></div><div class="line">            totalGroupCount = topGroups.totalGroupCount;</div><div class="line">            GroupDocs&lt;BytesRef&gt;[] groups = topGroups.groups;</div><div class="line">            <span class="comment">//开始对组进行遍历</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups.length; i++) &#123;</div><div class="line">                <span class="keyword">long</span> totalHits = iterGroupDocs(indexSearcher, groups[i]);<span class="comment">//获得这个组内一共多少doc</span></div><div class="line">                <span class="comment">//处理完一次分页，groupDocsOffset要更新</span></div><div class="line">                groupDocsOffset += groupDocsLimit;</div><div class="line">                <span class="comment">//如果组内还有数据，即模拟组内分页的情况，那么应该继续遍历组内剩下的doc</span></div><div class="line">                <span class="keyword">while</span> (groupDocsOffset &lt; totalHits) &#123;</div><div class="line">                    topGroups = groupingDemo.group(indexSearcher, query, <span class="string">"author"</span>, groupDocsOffset, groupDocsLimit, groupOffset, groupLimit);</div><div class="line">                    <span class="comment">//这里面的组一定要和外层for循环正在处理的组保持一致，其实这里面浪费了搜索数据，为什么？</span></div><div class="line">                    <span class="comment">//因为Lucene是对多个组同时进行组内向后翻页，而我只是一个组一个组的处理，其它不处理的组相当于是浪费的</span></div><div class="line">                    <span class="comment">//所以从这种角度来说，设置groupLimit为1比较合理，即每次处理一个组，而每次只将一个组的组内文档向后翻页</span></div><div class="line">                    GroupDocs&lt;BytesRef&gt; group = topGroups.groups[i];</div><div class="line">                    totalHits = iterGroupDocs(indexSearcher, group);</div><div class="line">                    <span class="comment">//此时需要更新组内偏移量</span></div><div class="line">                    groupDocsOffset += groupDocsLimit;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//至此，一个组内的doc全部遍历完毕，开始下一组</span></div><div class="line">                groupDocsOffset = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            groupOffset += groupLimit;</div><div class="line">            System.out.println(<span class="string">"#### 结束组的分页"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">iterGroupDocs</span><span class="params">(IndexSearcher indexSearcher, GroupDocs&lt;BytesRef&gt; groupDocs)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">long</span> totalHits = groupDocs.totalHits;</div><div class="line">        System.out.println(<span class="string">"\t#### 开始组内分页"</span>);</div><div class="line">        System.out.println(<span class="string">"\t分组名称："</span> + groupDocs.groupValue.utf8ToString());</div><div class="line">        ScoreDoc[] scoreDocs = groupDocs.scoreDocs;</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            System.out.println(<span class="string">"\t\t组内记录："</span> + indexSearcher.doc(scoreDoc.doc));</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"\t#### 结束组内分页"</span>);</div><div class="line">        <span class="keyword">return</span> totalHits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> TopGroups&lt;BytesRef&gt; <span class="title">group</span><span class="params">(IndexSearcher indexSearcher, Query query, String groupField,</span></span></div><div class="line">                                     <span class="keyword">int</span> groupDocsOffset, <span class="keyword">int</span> groupDocsLimit, <span class="keyword">int</span> groupOffset, <span class="keyword">int</span> groupLimit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="keyword">return</span> group(indexSearcher, query, Sort.RELEVANCE, Sort.RELEVANCE, groupField, groupDocsOffset, groupDocsLimit, groupOffset, groupLimit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> TopGroups&lt;BytesRef&gt; <span class="title">group</span><span class="params">(IndexSearcher indexSearcher, Query query, Sort groupSort, Sort withinGroupSort, String groupField,</span></span></div><div class="line">                                     <span class="keyword">int</span> groupDocsOffset, <span class="keyword">int</span> groupDocsLimit, <span class="keyword">int</span> groupOffset, <span class="keyword">int</span> groupLimit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//实例化GroupingSearch实例，传入分组域</span></div><div class="line">        GroupingSearch groupingSearch = <span class="keyword">new</span> GroupingSearch(groupField);</div><div class="line">        <span class="comment">//设置组间排序方式</span></div><div class="line">        groupingSearch.setGroupSort(groupSort);</div><div class="line">        <span class="comment">//设置组内排序方式</span></div><div class="line">        groupingSearch.setSortWithinGroup(withinGroupSort);</div><div class="line">        <span class="comment">//是否要填充每个返回的group和groups docs的排序field</span></div><div class="line">        groupingSearch.setFillSortFields(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">//设置用来缓存第二阶段搜索的最大内存，单位MB，第二个参数表示是否缓存评分</span></div><div class="line">        groupingSearch.setCachingInMB(<span class="number">64.0</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="comment">//是否计算符合查询条件的所有组</span></div><div class="line">        groupingSearch.setAllGroups(<span class="keyword">true</span>);</div><div class="line">        groupingSearch.setAllGroupHeads(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">//设置一个分组内的上限</span></div><div class="line">        groupingSearch.setGroupDocsLimit(groupDocsLimit);</div><div class="line">        <span class="comment">//设置一个分组内的偏移</span></div><div class="line">        groupingSearch.setGroupDocsOffset(groupDocsOffset);</div><div class="line">        TopGroups&lt;BytesRef&gt; result = groupingSearch.search(indexSearcher, query, groupOffset, groupLimit);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如组的分页大小是2，组内分页大小是2，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#### 组的分页大小为：2</div><div class="line">#### 组内分页大小为：2</div><div class="line">#### 开始组的分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C</div><div class="line">        组内记录：Document&lt;stored&lt;ID:8&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通C&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:9&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C语言详解&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C</div><div class="line">        组内记录：Document&lt;stored&lt;ID:10&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C语言调优&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C++</div><div class="line">        组内记录：Document&lt;stored&lt;ID:11&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通C++&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:12&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C++语言详解&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C++</div><div class="line">        组内记录：Document&lt;stored&lt;ID:13&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C++语言调优&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">#### 结束组的分页</div><div class="line">#### 开始组的分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:5&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Spring Cloud&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:6&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Hibernate&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:2&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通MyBatis&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:3&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Struts&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:4&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Spring&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:1&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Java&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:7&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通JVM&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">#### 结束组的分页</div></pre></td></tr></table></figure></p>
<p>例如组的分页大小是1，组内分页大小是3，结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#### 组的分页大小为：1</div><div class="line">#### 组内分页大小为：3</div><div class="line">#### 开始组的分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C</div><div class="line">        组内记录：Document&lt;stored&lt;ID:8&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通C&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:9&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C语言详解&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:10&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C语言调优&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">#### 结束组的分页</div><div class="line">#### 开始组的分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：C++</div><div class="line">        组内记录：Document&lt;stored&lt;ID:11&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通C++&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:12&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C++语言详解&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:13&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:C++&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:C++语言调优&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">#### 结束组的分页</div><div class="line">#### 开始组的分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:5&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Spring Cloud&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:6&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Hibernate&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:2&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通MyBatis&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:3&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Struts&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:4&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Spring&gt;&gt;</div><div class="line">        组内记录：Document&lt;stored&lt;ID:1&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通Java&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">    #### 开始组内分页</div><div class="line">    分组名称：Java</div><div class="line">        组内记录：Document&lt;stored&lt;ID:7&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;author:Java&gt; stored,indexed,tokenized,omitNorms,indexOptions=DOCS&lt;content:一周精通JVM&gt;&gt;</div><div class="line">    #### 结束组内分页</div><div class="line">#### 结束组的分页</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抛出问题&quot;&gt;&lt;a href=&quot;#抛出问题&quot; class=&quot;headerlink&quot; title=&quot;抛出问题&quot;&gt;&lt;/a&gt;抛出问题&lt;/h3&gt;&lt;p&gt;在 RDBMS 中，我们可以使用 GROUP BY 来对检索的数据进行分组，同样地，想要在 Lucene 中实现分组要如何做
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 实现任意词搜索命中并返回位置信息</title>
    <link href="http://www.codepub.cn/2017/10/13/lucene-implements-any-word-search-and-returns-location-information/"/>
    <id>http://www.codepub.cn/2017/10/13/lucene-implements-any-word-search-and-returns-location-information/</id>
    <published>2017-10-13T14:29:56.000Z</published>
    <updated>2017-11-20T14:18:34.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>如果把这个标题拆分成两个来讲，那么每一个都很好解决，下文会进行详述，而如果把这两者看做是与条件并加上其它限制，则实现起来比较困难，本文就是要探讨在需求繁多的情况下，如何优雅地实现。比如需求如下</p>
<ul>
<li>保留标点符号，否则去掉标点的话，在标点两边的词可能会匹配上，比如“你好，小甜甜”，去掉标点切分是『你|好|小|甜|甜』，那么『好小』有可能会命中，而如果切分成『你|好|，|小|甜|甜』，则『好小』无法命中</li>
<li>只要包含搜索词，要求对任意搜索词均可命中<ul>
<li>比如“我爱你中国”，不同的分词工具会切分出不同的结果</li>
<li>『我|爱|你|中国』或者『我爱你|中国』或者『我|爱|你|中|国』等，那么要求搜索“我爱”或者“爱你”或者“你中”等都要命中</li>
</ul>
</li>
<li>需要获取命中词的positions信息<ul>
<li>还是以“我爱你中国”为例，如果搜“你中”，那么需要返回结果命中，并给出positions信息，例如start=2表示“你中”在原文本中是从第2个位置开始</li>
</ul>
</li>
<li>可以设置slop<ul>
<li>什么是slop，简单来说slop是指两个项的位置之间允许的最大间隔距离</li>
<li>为什么要设置slop呢？比如小黄文为了防止敏感词被屏蔽，会在敏感词中间加上干扰词，例如<code>性%=$虐待</code>，那么直接搜<code>性虐待</code>无法命中</li>
<li>只要设置slop为3，即相当于搜<code>性[***]虐待</code>，这里面的<code>[***]</code>就代表slop为3，可以匹配任意三个字</li>
</ul>
</li>
<li>不要存储Field的值<ul>
<li>如果可以存储的话，可以通过Document获取原文本，再用TokenStream分析该文本，使用QueryScore初始化TokenStream的分析结果，遍历每个token根据TokenScore的得分判断是否命中，若命中则输出位置信息或者起始偏移量即可</li>
<li>但是存储Field的值是需要占用硬盘空间的，当需要索引海量的文本的时候，会导致索引体积非常大，搜索性能变差</li>
<li>当然还可以通过将索引拆分成多份存储实现降低索引体积的目的，这也是一个方法，不过治标不治本</li>
</ul>
</li>
<li>不要存储TermVectors<ul>
<li>同样地如果可以存储的话，可以通过TermVectors获取Terms再遍历TermsEnum，获取PostingsEnum得到positions信息，缺点在于只能实现单个字（Term）的搜索匹配</li>
<li>但是存储TermVectors同样占用硬盘空间，为了缩小索引体积，不要存储</li>
</ul>
</li>
<li>实现与逻辑，比如搜索“你中 &amp; 我爱”表示两个词都要命中</li>
<li>实现或逻辑，比如搜索“你中 | 我爱”表示两个词至少要有一个命中</li>
</ul>
<p>如果想要实现百分之百的任意词搜索命中，那么只能按字切分，因为没有任何分词工具能够保证切出来的词与搜索词是一致的。在上面说到为了达到匹配干扰词的目的，需要设置slop，但是会有一定的误判率，本来不该匹配的在设置slop之后也匹配上了。除了设置slop这种方式，还有一种方法，就是在索引阶段只保留汉字，其它的标点符号和干扰符号统统去掉，当然这也存在一定的误判率，而且获取的positions信息已经不是原文本中正确的positions信息了。两种方式的权衡与取舍可以根据业务需求而定，这两种方式都不会漏判，但是均会有误判。</p>
<h3 id="简单需求的实现"><a href="#简单需求的实现" class="headerlink" title="简单需求的实现"></a>简单需求的实现</h3><p>如果并不要求满足上面所有的需求，而仅仅满足其中任何一个，那么实现起来都是非常简单的，以下代码均基于Lucene 5.5.0实现，示例如下。</p>
<h4 id="仅要求任意搜索词命中"><a href="#仅要求任意搜索词命中" class="headerlink" title="仅要求任意搜索词命中"></a>仅要求任意搜索词命中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnyMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</div><div class="line">    RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">    Document document = <span class="keyword">new</span> Document();</div><div class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, <span class="string">"我爱你中国"</span>, Field.Store.NO));</div><div class="line">    indexWriter.addDocument(document);</div><div class="line">    indexWriter.commit();</div><div class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">    PhraseQuery phraseQuery = <span class="keyword">new</span> PhraseQuery.Builder().add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"你"</span>)).add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"中"</span>)).setSlop(<span class="number">0</span>).build();</div><div class="line">    TopDocs search = indexSearcher.search(phraseQuery, Integer.MAX_VALUE);</div><div class="line">    System.out.println(search.totalHits);</div><div class="line">    <span class="comment">//OR search like this</span></div><div class="line">    MultiPhraseQuery multiPhraseQuery = <span class="keyword">new</span> MultiPhraseQuery();</div><div class="line">    Term first = <span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"你"</span>);</div><div class="line">    Term second = <span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"中"</span>);</div><div class="line">    multiPhraseQuery.add(<span class="keyword">new</span> Term[]&#123;first, second&#125;);</div><div class="line">    search = indexSearcher.search(multiPhraseQuery, Integer.MAX_VALUE);</div><div class="line">    System.out.println(search.totalHits);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可以存储Field的值"><a href="#可以存储Field的值" class="headerlink" title="可以存储Field的值"></a>可以存储Field的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStoreFieldMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InvalidTokenOffsetsException &#123;</div><div class="line">    RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">    Document document = <span class="keyword">new</span> Document();</div><div class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, <span class="string">"我爱你中国"</span>, Field.Store.YES));</div><div class="line">    indexWriter.addDocument(document);</div><div class="line">    indexWriter.commit();</div><div class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">    PhraseQuery phraseQuery = <span class="keyword">new</span> PhraseQuery.Builder().add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"你"</span>)).add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"中"</span>)).setSlop(<span class="number">0</span>).build();</div><div class="line">    TopDocs search = indexSearcher.search(phraseQuery, Integer.MAX_VALUE);</div><div class="line">    ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">        String content = indexSearcher.doc(scoreDoc.doc).get(<span class="string">"content"</span>);</div><div class="line">        TokenStream contentStream = <span class="keyword">new</span> StandardAnalyzer().tokenStream(<span class="string">"content"</span>, content);</div><div class="line">        CharTermAttribute charTermAttribute = contentStream.addAttribute(CharTermAttribute.class);</div><div class="line">        OffsetAttribute offsetAttribute = contentStream.addAttribute(OffsetAttribute.class);</div><div class="line">        QueryScorer queryScorer = <span class="keyword">new</span> QueryScorer(phraseQuery);</div><div class="line">        queryScorer.setMaxDocCharsToAnalyze(Integer.MAX_VALUE);</div><div class="line">        TokenStream init = queryScorer.init(contentStream);</div><div class="line">        <span class="keyword">if</span> (init != <span class="keyword">null</span>) &#123;</div><div class="line">            contentStream = init;</div><div class="line">        &#125;</div><div class="line">        contentStream.reset();</div><div class="line">        queryScorer.startFragment(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">int</span> startOffset, endOffset;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> next = contentStream.incrementToken(); next &amp;&amp; (offsetAttribute.startOffset() &lt; Integer.MAX_VALUE); next = contentStream.incrementToken()) &#123;</div><div class="line">            startOffset = offsetAttribute.startOffset();</div><div class="line">            endOffset = offsetAttribute.endOffset();</div><div class="line">            <span class="keyword">if</span> (startOffset &gt; content.length() || endOffset &gt; content.length()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenOffsetsException(<span class="string">"Token "</span> + charTermAttribute.toString() + <span class="string">" exceeds length of provided text sized "</span> + content.length());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">float</span> res = queryScorer.getTokenScore();</div><div class="line">            <span class="keyword">if</span> (res &gt; Float.valueOf(<span class="number">0</span>) &amp;&amp; startOffset &lt;= endOffset) &#123;</div><div class="line">                System.out.println(<span class="string">"hits: "</span> + content.substring(startOffset, endOffset) + <span class="string">", start: "</span> + startOffset);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        contentStream.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可以存储TermVectors的值"><a href="#可以存储TermVectors的值" class="headerlink" title="可以存储TermVectors的值"></a>可以存储TermVectors的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTermVectorsMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InvalidTokenOffsetsException &#123;</div><div class="line">    RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> StandardAnalyzer()));</div><div class="line">    Document document = <span class="keyword">new</span> Document();</div><div class="line">    FieldType fieldType = <span class="keyword">new</span> FieldType();</div><div class="line">    fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);</div><div class="line">    fieldType.setStoreTermVectorPositions(<span class="keyword">true</span>);</div><div class="line">    fieldType.setStoreTermVectors(<span class="keyword">true</span>);</div><div class="line">    document.add(<span class="keyword">new</span> Field(<span class="string">"content"</span>, <span class="string">"我爱你中国"</span>, fieldType));</div><div class="line">    indexWriter.addDocument(document);</div><div class="line">    indexWriter.commit();</div><div class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">    Term searchTerm = <span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"中"</span>);</div><div class="line">    PhraseQuery phraseQuery = <span class="keyword">new</span> PhraseQuery.Builder().add(searchTerm).setSlop(<span class="number">0</span>).build();</div><div class="line">    TopDocs search = indexSearcher.search(phraseQuery, Integer.MAX_VALUE);</div><div class="line">    ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">        Terms content = indexSearcher.getIndexReader().getTermVector(scoreDoc.doc, <span class="string">"content"</span>);</div><div class="line">        TermsEnum iterator = content.iterator();</div><div class="line">        BytesRef bytesRef;</div><div class="line">        <span class="keyword">while</span> ((bytesRef = iterator.next()) != <span class="keyword">null</span>) &#123;</div><div class="line">            PostingsEnum postings = iterator.postings(<span class="keyword">null</span>, PostingsEnum.ALL);</div><div class="line">            <span class="keyword">if</span> (postings.nextDoc() != Spans.NO_MORE_DOCS) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; postings.freq(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (searchTerm.text().equals(bytesRef.utf8ToString())) &#123;</div><div class="line">                        System.out.println(<span class="string">"hits: "</span> + bytesRef.utf8ToString() + <span class="string">", start: "</span> + postings.nextPosition());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复杂需求的实现"><a href="#复杂需求的实现" class="headerlink" title="复杂需求的实现"></a>复杂需求的实现</h3><p>实现某一个简单的需求就不再举例了，下面要讲解如何实现复杂的需求，也就是说，要同时满足上面的需求列表，而不仅仅是只满足其中的某一条。首先需要解决的就是分词之后保留标点符号的问题，在Lucene中，我并没有找到原生的支持保留标点符号的Analyzer，于是只能自己造轮子了。</p>
<h4 id="保留标点符号的分词器"><a href="#保留标点符号的分词器" class="headerlink" title="保留标点符号的分词器"></a>保留标点符号的分词器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Tokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.LowerCaseFilter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.pattern.PatternTokenizer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"></div><div class="line"><span class="meta">@Log</span>4j2</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservePunctuationAnalyzer</span> <span class="keyword">extends</span> <span class="title">Analyzer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReservePunctuationAnalyzer</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> TokenStreamComponents <span class="title">createComponents</span><span class="params">(String fieldName)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Tokenizer source;</div><div class="line">        source = <span class="keyword">new</span> PatternTokenizer(Pattern.compile(<span class="string">""</span>), -<span class="number">1</span>);</div><div class="line">        TokenStream result = <span class="keyword">new</span> LowerCaseFilter(source);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenStreamComponents(source, result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分词测试如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    String input = <span class="string">"你好，小甜甜。"</span>;</div><div class="line">    TokenStream test = <span class="keyword">new</span> ReservePunctuationAnalyzer().tokenStream(<span class="string">"test"</span>, input);</div><div class="line">    CharTermAttribute charTermAttribute = test.addAttribute(CharTermAttribute.class);</div><div class="line">    OffsetAttribute offsetAttribute = test.addAttribute(OffsetAttribute.class);</div><div class="line">    test.reset();</div><div class="line">    <span class="keyword">while</span> (test.incrementToken()) &#123;</div><div class="line">        System.out.println(<span class="string">"token:["</span> + charTermAttribute + <span class="string">"], offset:["</span> + offsetAttribute.startOffset() + <span class="string">"]"</span>);</div><div class="line">    &#125;</div><div class="line">    test.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分词结果输出如下</p>
<blockquote>
<p>token:[你], offset:[0]<br>token:[好], offset:[1]<br>token:[，], offset:[2]<br>token:[小], offset:[3]<br>token:[甜], offset:[4]<br>token:[甜], offset:[5]<br>token:[。], offset:[6]</p>
</blockquote>
<h4 id="任意词搜索命中并返回positions信息"><a href="#任意词搜索命中并返回positions信息" class="headerlink" title="任意词搜索命中并返回positions信息"></a>任意词搜索命中并返回positions信息</h4><p>下面再来解决在不存储Field、不存储TermVectors的情况下，如何实现任意词搜索命中并返回positions信息，同时还可以设置slop的值。要实现这些功能就需要用到SpanQuery及其一系列的子类，先来看一张继承关系图，这些都是即将要使用到的类。</p>
<div align="center"><br><a href="http://7xig3q.com1.z0.glb.clouddn.com/spanquery_and_subclasses.jpg" title="SpanQuery And Subclasses" target="_blank" rel="external"><img src="http://7xig3q.com1.z0.glb.clouddn.com/spanquery_and_subclasses.jpg" alt="SpanQuery And Subclasses" title="SpanQuery And Subclasses"></a><br></div>

<p>SpanQuery的doc注释很简单，就一句话“Base class for span-based queries”，基于跨度查询的基类。而真正具有实际作用的是其各个子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.FieldType;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.LongField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanNearQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanTermQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanWeight;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.Spans;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.lucene.search.spans.SpanNearQuery.newOrderedNearQuery;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/10/13 14:29.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: TODO</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpanNearQueryDemo</span> </span>&#123;</div><div class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</div><div class="line">        String input = <span class="string">"现有的中文分词算法可分为三大类：基于字符串匹配的类基分词方法、基于理解的分词方法和基于统计的分词方法。"</span>;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> ReservePunctuationAnalyzer());</div><div class="line">        <span class="keyword">try</span> (IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, indexWriterConfig)) &#123;</div><div class="line">            Document document = <span class="keyword">new</span> Document();</div><div class="line">            FieldType fieldType = <span class="keyword">new</span> FieldType();</div><div class="line">            fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);</div><div class="line">            Field field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            LongField IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">1</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法是很难很复杂滴"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">2</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法可以大幅度提升程序性能"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">3</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line">            indexWriter.commit();</div><div class="line"></div><div class="line">            IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">            SpanTermQuery first = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"类"</span>));</div><div class="line">            SpanTermQuery second = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"基"</span>));</div><div class="line">            SpanNearQuery spanNearQuery = newOrderedNearQuery(<span class="string">"title"</span>).addClause(first).addClause(second).build();</div><div class="line">            SpanWeight weight = spanNearQuery.createWeight(indexSearcher, <span class="keyword">true</span>);</div><div class="line">            List&lt;LeafReaderContext&gt; leaves = indexSearcher.getIndexReader().getContext().leaves();</div><div class="line">            <span class="keyword">for</span> (LeafReaderContext leaf : leaves) &#123;</div><div class="line">                Spans spans = weight.getSpans(leaf, SpanWeight.Postings.POSITIONS);</div><div class="line">                <span class="keyword">while</span> (spans.nextDoc() != Spans.NO_MORE_DOCS) &#123;</div><div class="line">                    Document doc = leaf.reader().document(spans.docID());</div><div class="line">                    <span class="keyword">while</span> (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) &#123;</div><div class="line">                        System.out.println(<span class="string">"doc id = "</span> + spans.docID() + <span class="string">", doc IDX= "</span> + doc.get(<span class="string">"IDX"</span>) + <span class="string">", start position = "</span> + spans.startPosition() + <span class="string">", end "</span> +</div><div class="line">                                <span class="string">"position = "</span> + spans.endPosition());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">            <span class="comment">// 输出结果是</span></div><div class="line">            <span class="comment">// doc id = 0, doc IDX= 1, start position = 24, end position = 26</span></div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">            System.out.println();</div><div class="line">            <span class="comment">//修改slop，设置1，默认是0</span></div><div class="line">            spanNearQuery = newOrderedNearQuery(<span class="string">"title"</span>).addClause(first).addClause(second).setSlop(<span class="number">1</span>).build();</div><div class="line">            weight = spanNearQuery.createWeight(indexSearcher, <span class="keyword">true</span>);</div><div class="line">            leaves = indexSearcher.getIndexReader().getContext().leaves();</div><div class="line">            <span class="keyword">for</span> (LeafReaderContext leaf : leaves) &#123;</div><div class="line">                Spans spans = weight.getSpans(leaf, SpanWeight.Postings.POSITIONS);</div><div class="line">                <span class="keyword">while</span> (spans.nextDoc() != spans.NO_MORE_DOCS) &#123;</div><div class="line">                    Document doc = leaf.reader().document(spans.docID());</div><div class="line">                    <span class="keyword">while</span> (spans.nextStartPosition() != spans.NO_MORE_POSITIONS) &#123;</div><div class="line">                        System.out.println(<span class="string">"doc id = "</span> + spans.docID() + <span class="string">", doc IDX= "</span> + doc.get(<span class="string">"IDX"</span>) + <span class="string">", start position = "</span> + spans.startPosition() + <span class="string">", end "</span> +</div><div class="line">                                <span class="string">"position = "</span> + spans.endPosition());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">            <span class="comment">// 输出结果是</span></div><div class="line">            <span class="comment">// doc id = 0, doc IDX= 1, start position = 14, end position = 17</span></div><div class="line">            <span class="comment">// doc id = 0, doc IDX = 1, start position = 24, end position = 26</span></div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现逻辑与查询"><a href="#实现逻辑与查询" class="headerlink" title="实现逻辑与查询"></a>实现逻辑与查询</h4><p>通过上面的图，想必你也知道，Lucene官方并不对SpanAndQuery提供支持，在Lucene的官方讨论组中，有人发起过<a href="https://issues.apache.org/jira/browse/LUCENE-3371" target="_blank" rel="external">支持SpanAndQuery的issue</a>，但是一直没有获得官方的回应。不过已经有商业公司实现了这种搜索技术，公司名称是<a href="https://www.searchtechnologies.com/" target="_blank" rel="external">SearchTechnologies</a>，API参见<a href="https://wiki.searchtechnologies.com/javadoc/qpl0.3snap/index.html?com/searchtechnologies/qpl/solr/queryoperators/SpanAndQuery.html" target="_blank" rel="external">SpanAndQuery</a>，但是并不开源（So Sad），我没有找到其实现的具体源码，如果你知道的话，烦请告知我一下。</p>
<p>既然官方不予支持，那就只能自己造轮子了，逻辑上来讲，也不复杂，有两种方式可以实现。</p>
<p>第一种方式，从词的角度，例如『爱你』和『你中』两个搜索词实现逻辑与，那么只要分别地把每一个搜索词都单独搜一下，最后在命中结果中取交集，就可以实现逻辑与的功能，代码写起来也很简单，在此不予示例。</p>
<p>第二种方式，从Term的角度，例如『爱你』如果按字切分，那么能够切成两个Term，分别是『爱』和『你』，这时候使用SpanNearQuery构造查询语句，加上一个很大的slop，但是不管slop多大，它总是有上限的，万一两个Term之间的距离超过slop，同样无法命中，所以说这种实现方式是存在漏洞的，除非你确定你的两个Term之间的距离不会超过某个具体的slop值，那么可以使用之。</p>
<p>注意在使用SpanNearQuery获取positions信息的时候，你不能够同时保证按字切分，又可以在两个搜索词之间设置slop值，这是因为如果用BooleanQuery去包装两个SpanNearQuery，那么将丢失positions信息。如果不按字切分，那么切出来的某个词就是一个Term，即将『爱你』和『你中』看成是两个Term，这时候是可以设置slop值的。如果按字切分，那么切成『爱|你』和『你|中』，实现逻辑与，如果设置slop值，相当于是『爱|slop值|你|slop值|你|slop值|中』，已经与逻辑与不匹配了，逻辑与的本意是『爱|slop值为0|你|slop为任意值|你|slop值为0|中』，请细细体会。</p>
<h4 id="实现逻辑或查询"><a href="#实现逻辑或查询" class="headerlink" title="实现逻辑或查询"></a>实现逻辑或查询</h4><p>官方已经对或逻辑提供了支持，就是SpanOrQuery，直接操练起来即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.FieldType;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.LongField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.lucene.search.spans.SpanNearQuery.newOrderedNearQuery;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/10/13 14:29.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: TODO</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpanOrQueryDemo</span> </span>&#123;</div><div class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</div><div class="line">        String input = <span class="string">"现有的中文分词算法可分为三大类：基于字符串匹配的类基分词方法、基于理解的分词方法和基于统计的分词方法。"</span>;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> ReservePunctuationAnalyzer());</div><div class="line">        <span class="keyword">try</span> (IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, indexWriterConfig)) &#123;</div><div class="line">            Document document = <span class="keyword">new</span> Document();</div><div class="line">            FieldType fieldType = <span class="keyword">new</span> FieldType();</div><div class="line">            fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);</div><div class="line">            Field field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            LongField IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">1</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法是很难很复杂滴"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">2</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法可以大幅度提升程序性能"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">3</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line">            indexWriter.commit();</div><div class="line">            IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line"></div><div class="line">            SpanTermQuery first = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"类"</span>));</div><div class="line">            SpanTermQuery second = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"基"</span>));</div><div class="line">            SpanNearQuery spanNearQueryFirst = newOrderedNearQuery(<span class="string">"title"</span>).addClause(first).addClause(second).build();</div><div class="line"></div><div class="line">            first = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"算"</span>));</div><div class="line">            second = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"法"</span>));</div><div class="line">            SpanNearQuery spanNearQuerySecond = newOrderedNearQuery(<span class="string">"title"</span>).addClause(first).addClause(second).build();</div><div class="line">            SpanOrQuery spanOrQuery = <span class="keyword">new</span> SpanOrQuery(spanNearQueryFirst, spanNearQuerySecond);</div><div class="line"></div><div class="line">            SpanWeight weight = spanOrQuery.createWeight(indexSearcher, <span class="keyword">true</span>);</div><div class="line">            List&lt;LeafReaderContext&gt; leaves = indexSearcher.getIndexReader().getContext().leaves();</div><div class="line">            <span class="keyword">for</span> (LeafReaderContext leaf : leaves) &#123;</div><div class="line">                Spans spans = weight.getSpans(leaf, SpanWeight.Postings.POSITIONS);</div><div class="line">                <span class="keyword">while</span> (spans.nextDoc() != Spans.NO_MORE_DOCS) &#123;</div><div class="line">                    Document doc = leaf.reader().document(spans.docID());</div><div class="line">                    <span class="keyword">while</span> (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) &#123;</div><div class="line">                        System.out.println(<span class="string">"doc id = "</span> + spans.docID() + <span class="string">", doc IDX= "</span> + doc.get(<span class="string">"IDX"</span>) + <span class="string">", start position = "</span> + spans.startPosition() + <span class="string">", end "</span> +</div><div class="line">                                <span class="string">"position = "</span> + spans.endPosition());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">            <span class="comment">// 输出结果是</span></div><div class="line">            <span class="comment">// doc id = 0, doc IDX= 1, start position = 7, end position = 9</span></div><div class="line">            <span class="comment">// doc id = 0, doc IDX= 1, start position = 24, end position = 26</span></div><div class="line">            <span class="comment">// doc id = 1, doc IDX= 2, start position = 3, end position = 5</span></div><div class="line">            <span class="comment">// doc id = 2, doc IDX= 3, start position = 3, end position = 5</span></div><div class="line">            <span class="comment">//================================================================</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现SpanAllNearQuery"><a href="#实现SpanAllNearQuery" class="headerlink" title="实现SpanAllNearQuery"></a>实现SpanAllNearQuery</h3><p>这是一个附加功能，因为目前还没有碰到这样的需求，但是这种查询实现起来非常有意思，所以在此简单讲解一下。这个问题的来源是有人提了个<a href="https://issues.apache.org/jira/browse/LUCENE-3371" target="_blank" rel="external">issue</a>，请求官方支持SpanAllNearQuery，但是同样地，官方不理不睬。果然公益的就是拽啊，完全不倾听用户的需求，不像商业公司，为了赚用户的钱，只要用户有需求，就尽力实现。</p>
<p>那么这个需求是什么样的呢？简单表示如下<code>a WITHIN 5 WORDS OF (b AND c)</code>，还可以把它换一种方式理解<code>(a WITHIN 5 WORDS OF b) AND (a WITHIN 5 WORDS OF c)</code>，就是说我要查询，在a的前面5个或者后面5个token中出现b和c的所有结果集。要实现这个功能，需要借助于SpanNotQuery和SpanOrQuery，SpanOrQuery在实现或逻辑中已经介绍过了，那么SpanNotQuery又是什么意思呢？举例如下</p>
<blockquote>
<p>SpanNotQuery(a, b, 5, 5)表示在a的前5个或者后5个token中不能出现b<br>SpanNotQuery(a, c, 5, 5)表示在a的前5个或者后5个token中不能出现c</p>
</blockquote>
<p>下面先从逻辑上先实现这个需求，要获得在a的前面或后面5个token中出现b和c，需要将其反转理解，先查询在a的前面5个或者后面5个token中不能出现b『SpanNotQuery(a, b, 5, 5)』或者在a的前面5个或者后面5个token中不能出现c的结果『SpanNotQuery(a, c, 5, 5)』，再用SpanOrQuery来组合『SpanNotQuery(a, b, 5, 5)』和『SpanNotQuery(a, c, 5, 5)』实现或逻辑，最后用SpanNotQuery排除掉SpanOrQuery的结果集，那么剩下的就是在a的前面5个或者后面5个能出现b也能出现c的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.WhitespaceAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.IntField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanNotQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanOrQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanTermQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line">  * Created by wangxu on 2017/06/16 16:02.</div><div class="line"> * &lt;/p&gt;</div><div class="line">  * &lt;p&gt;</div><div class="line">  * Description: TODO</div><div class="line">  * &lt;/p&gt;</div><div class="line">  *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line">  * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line">  * Licence: Apache v2 License</div><div class="line"> */<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpanAllNearQueryDemo</span> </span>&#123;</div><div class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">  IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer()));</div><div class="line">  Document document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X b X X X X a X X X X c X"</span>, Field.Store.YES));<span class="comment">//命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">1</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X X X X X b a c X X X X X"</span>, Field.Store.YES));<span class="comment">//命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">2</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X b X X X X a a X X X X c"</span>, Field.Store.YES));<span class="comment">//不命中，不能同时以两个a为中心，两个a必选其一</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">3</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X b X X X X X a X X X X c"</span>, Field.Store.YES));<span class="comment">//不命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">4</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X b X X X X a X X X X X c"</span>, Field.Store.YES));<span class="comment">//不命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">5</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"b X X X X X a X X X X X c"</span>, Field.Store.YES));<span class="comment">//不命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">6</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"b X X X X X a X X X X X X"</span>, Field.Store.YES));<span class="comment">//不命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">7</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line"></div><div class="line">  document = <span class="keyword">new</span> Document();</div><div class="line">  document.add(<span class="keyword">new</span> TextField(<span class="string">"key"</span>, <span class="string">"X X X X X X a X X X X X X"</span>, Field.Store.YES));<span class="comment">//不命中</span></div><div class="line">  document.add(<span class="keyword">new</span> IntField(<span class="string">"IDX"</span>, <span class="number">8</span>, Field.Store.YES));</div><div class="line">  indexWriter.addDocument(document);</div><div class="line">  indexWriter.commit();</div><div class="line"></div><div class="line">  IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(indexWriter));</div><div class="line">  SpanTermQuery a = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"key"</span>, <span class="string">"a"</span>));</div><div class="line">  SpanTermQuery b = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"key"</span>, <span class="string">"b"</span>));</div><div class="line">  SpanTermQuery c = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"key"</span>, <span class="string">"c"</span>));</div><div class="line">  SpanOrQuery exclude = <span class="keyword">new</span> SpanOrQuery(<span class="keyword">new</span> SpanNotQuery(a, b, <span class="number">5</span>, <span class="number">5</span>), <span class="keyword">new</span> SpanNotQuery(a, c, <span class="number">5</span>, <span class="number">5</span>));</div><div class="line">  <span class="comment">//排除在a的前5个或者后5个不能出现b也不能出现c的document，那么剩下的就是在a的前5个token或者后5个token能够出现b和c的document</span></div><div class="line">  SpanNotQuery spanNotQuery = <span class="keyword">new</span> SpanNotQuery(a, exclude);</div><div class="line">  TopDocs search = indexSearcher.search(spanNotQuery, Integer.MAX_VALUE);</div><div class="line">  ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line"> <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            System.out.println(<span class="string">"hist IDX: "</span> + indexSearcher.doc(scoreDoc.doc).get(<span class="string">"IDX"</span>));</div><div class="line">  &#125;</div><div class="line">        indexSearcher.getIndexReader().close();</div><div class="line">  indexWriter.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SpanNearQuery实现通配符查询"><a href="#SpanNearQuery实现通配符查询" class="headerlink" title="SpanNearQuery实现通配符查询"></a>SpanNearQuery实现通配符查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.yuewen.nrzx.character.analyzer.ReservePunctuationAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.FieldType;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.LongField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.WildcardQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanNearQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spans.SpanTermQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpanNearQueryAndWildcardQueryDemo</span> </span>&#123;</div><div class="line">    <span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</div><div class="line">        String input = <span class="string">"现有的中文分词算法可分为三大类：基于字符串匹配的类基分词方法、基于理解的分词方法和基于统计的分词方法。"</span>;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> ReservePunctuationAnalyzer());</div><div class="line">        <span class="keyword">try</span> (IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, indexWriterConfig)) &#123;</div><div class="line">            Document document = <span class="keyword">new</span> Document();</div><div class="line">            FieldType fieldType = <span class="keyword">new</span> FieldType();</div><div class="line">            fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);</div><div class="line">            Field field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            LongField IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">1</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法是很难很复杂滴"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">2</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line"></div><div class="line">            input = <span class="string">"计算机算法可以大幅度提升程序性能"</span>;</div><div class="line">            document = <span class="keyword">new</span> Document();</div><div class="line">            field = <span class="keyword">new</span> Field(<span class="string">"title"</span>, input, fieldType);</div><div class="line">            IDX = <span class="keyword">new</span> LongField(<span class="string">"IDX"</span>, <span class="number">3</span>, Field.Store.YES);</div><div class="line">            document.add(field);</div><div class="line">            document.add(IDX);</div><div class="line">            indexWriter.addDocument(document);</div><div class="line">            indexWriter.commit();</div><div class="line">            IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">            <span class="comment">// 用?和*均可以实现SpanNearQuery的通配符查询，但是注意*在通配符查询中表示可以匹配0个或多个字符</span></div><div class="line">            <span class="comment">// 但是在SpanQuery中只能匹配相当于slop=1的情形，不能匹配slop大于1的情形</span></div><div class="line">            SpanTermQuery first = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"复"</span>));</div><div class="line">            SpanQuery wildcard = <span class="keyword">new</span> SpanMultiTermQueryWrapper&lt;&gt;(<span class="keyword">new</span> WildcardQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"?"</span>)));</div><div class="line">            SpanTermQuery last = <span class="keyword">new</span> SpanTermQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"滴"</span>));</div><div class="line"></div><div class="line">            SpanNearQuery spanNearQuery = <span class="keyword">new</span> SpanNearQuery.Builder(<span class="string">"title"</span>, <span class="keyword">true</span>).addClause(first).addClause(wildcard).addClause(last).build();</div><div class="line">            TopDocs search = indexSearcher.search(spanNearQuery, Integer.MAX_VALUE);</div><div class="line">            System.out.println(<span class="string">"IDX: "</span> + indexSearcher.doc(search.scoreDocs[<span class="number">0</span>].doc).get(<span class="string">"IDX"</span>));</div><div class="line"></div><div class="line">            wildcard = <span class="keyword">new</span> SpanMultiTermQueryWrapper&lt;&gt;(<span class="keyword">new</span> WildcardQuery(<span class="keyword">new</span> Term(<span class="string">"title"</span>, <span class="string">"*"</span>)));</div><div class="line">            spanNearQuery = <span class="keyword">new</span> SpanNearQuery.Builder(<span class="string">"title"</span>, <span class="keyword">true</span>).addClause(first).addClause(wildcard).addClause(last).build();</div><div class="line">            search = indexSearcher.search(spanNearQuery, Integer.MAX_VALUE);</div><div class="line">            System.out.println(<span class="string">"IDX: "</span> + indexSearcher.doc(search.scoreDocs[<span class="number">0</span>].doc).get(<span class="string">"IDX"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>服务器 CPU 以及内存信息</p>
<blockquote>
<p>$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</p>
</blockquote>
<p><code>24  Intel(R) Xeon(R) CPU E5-2420 v2 @ 2.20GHz</code></p>
<blockquote>
<p>$ free -g</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>total</th>
<th>used</th>
<th>free</th>
<th>shared</th>
<th>buffers</th>
<th>cached</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mem</td>
<td>62</td>
<td>56</td>
<td>6</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>-/+ buffers/cache</td>
<td>54</td>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Swap</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在公司内部，仅仅索引了十分之一的文档（Document数量：20023911），鉴于没有存储Field，也没有存储TermVectors，索引不算太大，简单测试了下，如果存储TermVectors的话，索引会从112GB增长到162GB，如果再存储Field的话，那么索引要超过200GB。此处的实验只是简单的单次搜索，没有测试与逻辑和或逻辑情况下的搜索情况。搜索阶段实验的结果如下所示</p>
<table>
<thead>
<tr>
<th>线程数目</th>
<th>搜索总次数</th>
<th>命中次数</th>
<th>搜索总耗时</th>
<th>平均单次耗时</th>
<th>搜索加构建Query耗时</th>
<th>平均单次耗时</th>
<th>索引大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>18820</td>
<td>18139</td>
<td>36001,698ms</td>
<td>1912.95ms</td>
<td>36011,989ms</td>
<td>1913.50ms</td>
<td>112GB</td>
</tr>
<tr>
<td>5</td>
<td>18820</td>
<td>18139</td>
<td>30775,283ms</td>
<td>1635.24ms</td>
<td>30785,538ms</td>
<td>1635.79ms</td>
<td>112GB</td>
</tr>
<tr>
<td>10</td>
<td>18820</td>
<td>18139</td>
<td>21637,515ms</td>
<td>1149.71ms</td>
<td>21647,953ms</td>
<td>1150.26ms</td>
<td>112GB</td>
</tr>
<tr>
<td>50</td>
<td>18820</td>
<td>18139</td>
<td>21572,506ms</td>
<td>1146.25ms</td>
<td>21583,101ms</td>
<td>1146.82ms</td>
<td>112GB</td>
</tr>
</tbody>
</table>
<p>索引阶段并没有做详细完备的实验，只是简单拉取了一点数据，记录如下，仅供参考。索引2080550个Document，统计从数据库拉取数据加更新数据到索引耗时2133s，平均每次耗时0.001s。只计算更新数据到索引中，不计算从数据库拉取数据耗时464s，平均每次耗时0.0002s，可见索引速度也是很快的，这全部得益于Lucene的优良设计。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;如果把这个标题拆分成两个来讲，那么每一个都很好解决，下文会进行详述，而如果把这两者看做是与条件并加上其它限制，则实现起来比较困难，本文就是要
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Lucene 中获取没有存储的字段值的几种方法</title>
    <link href="http://www.codepub.cn/2017/10/10/several-ways-to-get-the-field-values-that-are-not-stored-in-lucene/"/>
    <id>http://www.codepub.cn/2017/10/10/several-ways-to-get-the-field-values-that-are-not-stored-in-lucene/</id>
    <published>2017-10-10T14:31:02.000Z</published>
    <updated>2017-11-20T14:18:34.150Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，如果想要从Lucene索引中获取Field的值，那么需要在索引阶段设置Field.Store.YES才可以，然后在搜索阶段得到TopDocs对象之后，用它去获取ScoreDoc再取出Document，使用Document获取存储在索引中的值。但是我们都知道，存储字段是需要硬盘空间的，如果想要追求极致的存储空间并且获取Field的值，那么在不存储的情况下，如何获取呢？其实仔细思索一下，在我们只索引不存储的情况下，Lucene依然可以判断搜索是否命中，这说明在Lucene索引中依然存有一份Field的值，这样在搜索阶段才能判断是否匹配。本文就是探讨在这种情形下，使用Lucene的核心包获取没有存储的Field的值的几种方法，如果你还有其它不同的方法请留言。</p>
<ul>
<li><strong>testGetFieldByStore</strong> 演示存储Field值时如何获取</li>
<li><strong>testGetFieldByTerms</strong> 演示通过Terms获取没有存储的Field值</li>
<li><strong>testGetFieldByFieldDocWithSorted</strong> 演示通过FieldDoc获取没有存储的值</li>
<li><strong>testGetFieldByTermVector</strong> 演示通过TermVector获取没有存储的值</li>
<li><strong>testGetFieldByTermVectors</strong> 演示通过TermVectors获取没有存储的值</li>
</ul>
<p>这里补充一下，在lucene-suggest包中，有LuceneDictionary类，通过该类的getEntryIterator方法也能获取没有存储的Field的值，不过其本质和通过Terms获取方式一样，在此不再列举。源码示例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.WhitespaceAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.util.BytesRef;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.lucene.search.SortField.Type.STRING;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/10/10 17:33.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: Lucene 6.5.0</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetNonStoredFieldDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">    <span class="keyword">private</span> IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer()));</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetNonStoredFieldDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldByStore</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initIndexForStore();</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        TopDocs search = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">        ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            Document doc = indexSearcher.doc(scoreDoc.doc);</div><div class="line">            System.out.println(doc.get(<span class="string">"IDX"</span>) + <span class="string">"=&gt;"</span> + doc.get(<span class="string">"title"</span>));</div><div class="line">        &#125;</div><div class="line">        ramDirectory.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldByTerms</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initIndexForTerms();</div><div class="line">        Fields fields = MultiFields.getFields(DirectoryReader.open(ramDirectory));</div><div class="line">        Terms idx = fields.terms(<span class="string">"IDX"</span>);</div><div class="line">        Terms title = fields.terms(<span class="string">"title"</span>);</div><div class="line">        <span class="comment">//or you can use like this</span></div><div class="line">        <span class="comment">//TermsEnum idxIter = MultiFields.getTerms(DirectoryReader.open(ramDirectory), "IDX").iterator();</span></div><div class="line">        TermsEnum idxIter = idx.iterator();</div><div class="line">        TermsEnum titleIter = title.iterator();</div><div class="line">        BytesRef bytesRef;</div><div class="line">        <span class="keyword">while</span> ((bytesRef = idxIter.next()) != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(bytesRef.utf8ToString() + <span class="string">"=&gt;"</span> + titleIter.next().utf8ToString());</div><div class="line">        &#125;</div><div class="line">        ramDirectory.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldByFieldDocWithSorted</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initIndexForFieldDocWithSorted();</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        <span class="comment">//must use method which returns TopFieldDocs</span></div><div class="line">        TopFieldDocs search = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count, <span class="keyword">new</span> Sort(<span class="keyword">new</span> SortField(<span class="string">"IDX"</span>, STRING)));</div><div class="line">        ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            FieldDoc fieldDoc = (FieldDoc) scoreDoc;</div><div class="line">            Object[] fields = fieldDoc.fields;</div><div class="line">            <span class="keyword">if</span> (fields[<span class="number">0</span>] <span class="keyword">instanceof</span> BytesRef) &#123;</div><div class="line">                BytesRef temp = (BytesRef) fields[<span class="number">0</span>];</div><div class="line">                System.out.println(temp.utf8ToString() + <span class="string">"=&gt;"</span> + indexSearcher.doc(scoreDoc.doc).get(<span class="string">"title"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ramDirectory.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldByTermVector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initIndexForTermVector();</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        TopDocs search = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">        ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            <span class="keyword">int</span> doc = scoreDoc.doc;</div><div class="line">            Terms idx = indexSearcher.getIndexReader().getTermVector(doc, <span class="string">"IDX"</span>);</div><div class="line">            TermsEnum iterator = idx.iterator();</div><div class="line">            BytesRef bytesRef;</div><div class="line">            <span class="keyword">while</span> ((bytesRef = iterator.next()) != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(bytesRef.utf8ToString() + <span class="string">"=&gt;"</span> + indexSearcher.doc(doc).get(<span class="string">"title"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ramDirectory.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldByTermVectors</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        initIndexForTermVector();</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        TopDocs search = indexSearcher.search(<span class="keyword">new</span> MatchAllDocsQuery(), count);</div><div class="line">        ScoreDoc[] scoreDocs = search.scoreDocs;</div><div class="line">        <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">            <span class="keyword">int</span> doc = scoreDoc.doc;</div><div class="line">            Fields termVectors = indexSearcher.getIndexReader().getTermVectors(doc);</div><div class="line">            Terms idx = termVectors.terms(<span class="string">"IDX"</span>);</div><div class="line">            TermsEnum iterator = idx.iterator();</div><div class="line">            BytesRef bytesRef;</div><div class="line">            <span class="keyword">while</span> ((bytesRef = iterator.next()) != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(bytesRef.utf8ToString() + <span class="string">"=&gt;"</span> + indexSearcher.doc(doc).get(<span class="string">"title"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ramDirectory.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initIndexForStore</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST01"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE01"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST02"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE02"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST03"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE03"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST04"</span>, Field.Store.YES));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE04"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initIndexForTerms</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST01"</span>, Field.Store.NO));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE01"</span>, Field.Store.NO));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST02"</span>, Field.Store.NO));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE02"</span>, Field.Store.NO));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST03"</span>, Field.Store.NO));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE03"</span>, Field.Store.NO));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"IDX"</span>, <span class="string">"TEST04"</span>, Field.Store.NO));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE04"</span>, Field.Store.NO));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initIndexForTermVector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        FieldType fieldType = <span class="keyword">new</span> FieldType();</div><div class="line">        fieldType.setStoreTermVectors(<span class="keyword">true</span>);</div><div class="line">        fieldType.setIndexOptions(IndexOptions.DOCS);</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> Field(<span class="string">"IDX"</span>, <span class="string">"TEST01"</span>, fieldType));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE01"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> Field(<span class="string">"IDX"</span>, <span class="string">"TEST02"</span>, fieldType));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE02"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> Field(<span class="string">"IDX"</span>, <span class="string">"TEST03"</span>, fieldType));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE03"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> Field(<span class="string">"IDX"</span>, <span class="string">"TEST04"</span>, fieldType));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE04"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initIndexForFieldDocWithSorted</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"IDX"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"TEST01"</span>)));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE01"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"IDX"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"TEST02"</span>)));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE02"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"IDX"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"TEST03"</span>)));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE03"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line"></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> SortedDocValuesField(<span class="string">"IDX"</span>, <span class="keyword">new</span> BytesRef(<span class="string">"TEST04"</span>)));</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, <span class="string">"TITLE04"</span>, Field.Store.YES));</div><div class="line">        indexWriter.addDocument(document);</div><div class="line">        indexWriter.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，如果想要从Lucene索引中获取Field的值，那么需要在索引阶段设置Field.Store.YES才可以，然后在搜索阶段得到TopDocs对象之后，用它去获取ScoreDoc再取出Document，使用Document获取存储在索引中的值。但是我们都知道，存储字
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Logstash离线安装插件</title>
    <link href="http://www.codepub.cn/2017/09/29/logstash-offline-install-plugin/"/>
    <id>http://www.codepub.cn/2017/09/29/logstash-offline-install-plugin/</id>
    <published>2017-09-29T14:03:22.000Z</published>
    <updated>2017-11-20T14:18:34.117Z</updated>
    
    <content type="html"><![CDATA[<p>如果线上服务器可以连外网的话，当然是用官方提供的命令来安装插件最简单了，但是可惜的是，好多公司线上服务器是没有外网访问权限的，这就需要在使用某些插件的时候，进行离线安装。而离线安装有两种方式，一种是在可以联网的机器上安装插件，之后使用<code>prepare-offline-pack</code>命令打包，然后将打包文件上传到不能联网的服务器，再使用<code>prepare-offline-pack</code>解包，安装。但是这种方式太麻烦，要求你必须要有一个可以联网的机器，最好还是和不能联网的服务器相同的配置环境，这里推荐一种更好的方案，来解决离线安装插件的问题。</p>
<p>先演示一下，正常的联网环境是如何操作的，如下所示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster logstash-5.5.0]$ pwd</div><div class="line">/home/elastic/elasticsearch/logstash-5.5.0</div><div class="line">[elastic@escluster logstash-5.5.0]$ ./bin/logstash-plugin install logstash-filter-fingerprint</div><div class="line">Validating logstash-filter-fingerprint</div><div class="line">Installing logstash-filter-fingerprint</div><div class="line">Installation successful</div></pre></td></tr></table></figure></p>
<p>那么无法联网，首先需要在可以联网的机器上下载对应插件的压缩包，打开<a href="https://github.com/logstash-plugins" target="_blank" rel="external">Logstash Plugins</a>地址，直接搜索需要安装的插件名称，然后下载对应的<code>zip</code>或者<code>tar.gz</code>压缩包即可。也许你会说，我用的Logstash是5.5.0的，但是并没有对应版本的插件啊？不用担心，试一下如下命令，显示已经安装的所有插件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster logstash-5.5.0]$ ls -la vendor/bundle/jruby/1.9/gems</div><div class="line">total 652</div><div class="line">drwxrwxr-x. 203 elastic elastic 8192 Jun 30 23:56 .</div><div class="line">drwxrwxr-x.   9 elastic elastic  104 Jun 30 23:56 ..</div><div class="line">drwxrwxr-x.   7 elastic elastic 4096 Jun 30 23:56 addressable-2.3.8</div><div class="line">drwxrwxr-x.   3 elastic elastic 4096 Jun 30 23:56 arr-pm-0.0.10</div><div class="line">drwxrwxr-x.   6 elastic elastic 4096 Jun 30 23:56 atomic-1.1.99-java</div><div class="line">drwxrwxr-x.   5 elastic elastic   55 Jun 30 23:56 avl_tree-1.2.1</div><div class="line">drwxrwxr-x.   4 elastic elastic 4096 Jun 30 23:56 awesome_print-1.8.0</div><div class="line">drwxrwxr-x.   3 elastic elastic   16 Jun 30 23:56 aws-sdk-2.3.22</div><div class="line">drwxrwxr-x.   5 elastic elastic  104 Jun 30 23:56 aws-sdk-core-2.3.22</div><div class="line">drwxrwxr-x.   3 elastic elastic   16 Jun 30 23:56 aws-sdk-resources-2.3.22</div><div class="line">drwxrwxr-x.   5 elastic elastic 4096 Jun 30 23:56 aws-sdk-v1-1.67.0</div><div class="line">drwxrwxr-x.   7 elastic elastic 4096 Jun 30 23:56 backports-3.8.0</div><div class="line">......</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>可以看到，各种版本的插件都有，所以说，插件的版本和Logstash的版本并不要求一致，以安装<a href="https://github.com/logstash-plugins/logstash-filter-fingerprint" target="_blank" rel="external"><code>logstash-filter-fingerprint</code></a>插件为例，目前最新版是<code>v3.1.1</code>，下载上传到无法联网的服务器上，解压<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster ~]$ gunzip logstash-filter-fingerprint-3.1.1.tar.gz</div><div class="line">[elastic@escluster ~]$ tar -xvf logstash-filter-fingerprint-3.1.1.tar</div></pre></td></tr></table></figure></p>
<p>进入Logstash的目录，编辑<code>Gemfile</code>文件，在文件开头添加<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem "logstash-filter-fingerprint", :path =&gt; "/home/elastic/logstash-filter-fingerprint-3.1.1"</div></pre></td></tr></table></figure></p>
<p>保存退出，执行命令<code>./bin/logstash-plugin install --no-verify</code>安装，提示如下信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster logstash-5.5.0]$ ./bin/logstash-plugin install --no-verify</div><div class="line">Installing...</div><div class="line">LogStash::GemfileError: duplicate gem logstash-filter-fingerprint</div><div class="line">             add_gem at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/gemfile.rb:109</div><div class="line">                 gem at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/gemfile.rb:207</div><div class="line">              (eval) at (eval):52</div><div class="line">       instance_eval at org/jruby/RubyBasicObject.java:1598</div><div class="line">               parse at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/gemfile.rb:195</div><div class="line">                load at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/gemfile.rb:19</div><div class="line">             gemfile at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/command.rb:4</div><div class="line">  install_gems_list! at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/install.rb:146</div><div class="line">             execute at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/install.rb:61</div><div class="line">                 run at /home/elastic/elasticsearch/logstash-5.5.0/vendor/bundle/jruby/1.9/gems/clamp-0.6.5/lib/clamp/command.rb:67</div><div class="line">             execute at /home/elastic/elasticsearch/logstash-5.5.0/vendor/bundle/jruby/1.9/gems/clamp-0.6.5/lib/clamp/subcommand/execution.rb:11</div><div class="line">                 run at /home/elastic/elasticsearch/logstash-5.5.0/vendor/bundle/jruby/1.9/gems/clamp-0.6.5/lib/clamp/command.rb:67</div><div class="line">                 run at /home/elastic/elasticsearch/logstash-5.5.0/vendor/bundle/jruby/1.9/gems/clamp-0.6.5/lib/clamp/command.rb:132</div><div class="line">              (root) at /home/elastic/elasticsearch/logstash-5.5.0/lib/pluginmanager/main.rb:48</div></pre></td></tr></table></figure></p>
<p>很清晰，这是说在Gemfile中存在重复的<code>logstash-filter-fingerprint</code>，因为在原始的Gemfile中，存在通过联网进行安装的<code>logstash-filter-fingerprint</code>，打开Gemfile，找到并注释掉即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> gem <span class="string">"logstash-filter-fingerprint"</span></span></div></pre></td></tr></table></figure></p>
<p>再次执行安装命令，即可安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster logstash-5.5.0]$ ./bin/logstash-plugin install --no-verify</div><div class="line">Installing...</div><div class="line">Installation successful</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果线上服务器可以连外网的话，当然是用官方提供的命令来安装插件最简单了，但是可惜的是，好多公司线上服务器是没有外网访问权限的，这就需要在使用某些插件的时候，进行离线安装。而离线安装有两种方式，一种是在可以联网的机器上安装插件，之后使用&lt;code&gt;prepare-offlin
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Logstash" scheme="http://www.codepub.cn/tags/Logstash/"/>
    
  </entry>
  
  <entry>
    <title>2017年中随想</title>
    <link href="http://www.codepub.cn/2017/09/24/2017-first-half-random-thoughts/"/>
    <id>http://www.codepub.cn/2017/09/24/2017-first-half-random-thoughts/</id>
    <published>2017-09-24T13:43:34.000Z</published>
    <updated>2017-11-20T14:18:34.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h4><p>好久没有发文了，最近有价值的技术总结并不多，或者说，已经懒的去总结技术了，毕竟这事也挺耗费时间与精力的。虽说初衷是为了避免无病呻吟，结果却导致自己懈怠了，但是这并不能作为懒惰的理由。最近被一篇<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1506257488&amp;ver=412&amp;signature=1k7v0tDpQU-TvEL0MyTvVkb-xZ7hr9v4H9AzdMnFXm2aULMlPY7DlX1foSWb1c6ldULbBDygt9Ibpi8Xid26i-KJzMG*imhg5SrmLBGh4c*2pnUKdX4IT4mHbNiOk61q&amp;new=1" target="_blank" rel="external">《一个月就辞职：一个北大女生的求职悲欢》</a>文章刷屏了，一枚学霸姐，放弃在鹅厂的实习转正机会，毅然投奔在杭州网易的男友，只因为她无法接受异地或者同城异地的感情生活，遂写了这篇半是吐槽半是炫耀的软文，妹子和她的男友确实优秀，两个北大的研究生，一个拿着网易的高薪OFFER，一个弃鹅厂OFFER于不顾，毅然选择为了爱情抛弃面包。如果说这么优秀的妹子仅仅是吐槽找工作困难那是不可能的，头顶拥有着中国最顶级的学府北大的光环，试问全中国795万毕业生（2017年数据），光环度能比之更亮的恐怕凤毛麟角吧。所以这注定是一篇炫耀的软文，炫耀爱情也罢，炫耀能力也罢，炫耀北大的光环也罢，这都无可厚非，毕竟优秀的人有资格炫耀。当然了只有一种例外的情况会得到我的鄙视，那就是靠北京户口考上的北大，因为北大一方面是中国人的北大，另一方面是北京人的北大，这些拿着北京户口考上北大的人侵占了本该属于全中国的有为青年接受更好教育的机会，只希望他们能对得起对他们足够偏心的祖国以及那些因为偏心而导致无缘北大的有为学子们。所幸这个姑娘并不是北京人，所以我对她并无半点鄙视。</p>
<p>在这篇文章中，我无意中学到了这个优秀学霸的一个小习惯，就是多总结。原来在她准备校招的时候，做了详细的Excel表格，总结了投了哪些公司，收到了哪些公司的面试邀约，以及各个面试公司的进展，一轮、二轮、三轮、终面等等，这是一个非常值得学习的好习惯，对比我自身而言，在当时校招的时候，投了哪些公司我自己都不清楚，甚至说，哪些公司有结果了，哪些公司还毫无反馈，我自己都不甚清楚，与之一比，顿觉自惭形秽啊，所以一定要向优秀的人靠拢，观察他们，长期练习，日积月累，学会并总结出一套自我升级的理论，在以后的慢慢人生路上必然是大有裨益的。</p>
<p>其实这篇文章本来并不在计划之中，原先的计划是一年一篇年终总结就够了，不用劳心费力的去写那么多。但是最近想法有变，互联网的世界发展太快了，我脑子里的东西也太多了，这些想法整天在我的脑子里翻滚、碰撞、融合、升级等等，如果不做个记录的话，真的担心以后再也记不起来了，虽然我文笔浅薄，难登大雅，但是记得一个牛人说过，写好文章并没有什么特别的技巧，提起笔写就是了，所以从此刻开始，动手提笔，挥毫泼墨，您姑且一看吧。</p>
<h4 id="斜杠青年"><a href="#斜杠青年" class="headerlink" title="斜杠青年"></a>斜杠青年</h4><p>了解<a href="https://baike.baidu.com/item/%E6%96%9C%E6%9D%A0%E9%9D%92%E5%B9%B4/19447422" target="_blank" rel="external">斜杠青年</a>这个词是在逛知乎的时候偶然知道的，或许这是未来就业的一种潮流吧。随着社会的发展，个人必将更加地追求自我，这也导致多数人不可能一种职业干一辈子，所以将来人在短暂的一生中会承担更加多样化的职业角色，这样就诞生了诸多斜杠青年。</p>
<p>我本身是一名程序员，有着稳定的全职工作，但是我也在想，如果我不写程序的话，我能靠什么养活自己呢？或许我也该试试成为一名斜杠青年，这样不管以后我还写不写程序，或者以后还是不是人写程序，我都能够有一份收入的保障以免自己饿死。当然了有点杞人忧天，不过话说回来，即便不是为了免于饿死，如果你斜杠青年做的成功的话，多几项额外的收入不也是一件幸事吗？</p>
<p>说干就干，互联网的世界里机会还是很多的，鉴于我国单身男女已达2亿之多， 我一直觉得婚恋市场还有机会产生一个互联网巨头，当然不是世纪佳缘、珍爱网、百合网等的样子，这些网站已经彻底拉低了婚恋行业的道德品质，所谓的红娘已经被训练成了合格的保险推销员的样子，对用户资料不加审核，只管推销会员付费，至于你们合不合适，更不是他们思考的问题，只要给你配对，让你有更多付费的名目即可，这样即便你配不上，对他也没有任何损失，后续还可以继续为你配对牵线，又一个赚钱的好名目。</p>
<p>这些网站婚恋网站肆意造假，毫无底线，甚至可以说为了钱已经到了公然行骗的地步，只要你注册了这些婚恋网站，上来就是给你发站内信，如果你是男性，那么内容肯定是什么高学历白富美对你感兴趣，赶紧联系她吧，下一步想要联系就要付费，而至于这些对你有兴趣的美女之类的都是假的罢了。如果你是女性，那不说你也猜到了站内信的内容是什么，某某上市公司高管精英海龟对你感兴趣之类。</p>
<p>成为一名斜杠青年，我选择从做一个相亲公众号切入『本硕博相亲角』，这种试错成本最小，足不出户，一台电脑，一根网线，很契合程序员的生活，而且公众号放开了，任何个人都可以申请，几乎不需要任何成本，这样的好东西拿来随意鼓捣最适合不过了。但是万事开头难，在没有粉丝没有订阅用户的情况下，如何运营下去呢？我也加入了一些公众号运营者的群，看着这些虚伪的人天天去推荐他们的公众号却还在嘴里喊着为了兴趣才做的，不禁对之嗤之以鼻，如果仅仅为了兴趣，那么你就不应该花费那么大的精力去推广你的公众号去吸粉，这样的话，你已经被你的兴趣绑架了，本来兴趣是为了营造更好的生活，结果呢？你为了兴趣天天累死累活，然后恬不知耻地去到处骚扰别人，轰炸朋友圈推广自己的公众号，还在嘴里大喊我是为了兴趣！做公众号没什么可耻的，推广吸粉没什么可耻的，做公众号为了赚钱同样没什么可耻的，你本可以光明正大地说，我做公众号就是为了赚钱，我们多数人都是完全理解的，毕竟这世界上完全不顾利益却投入大量的精力去做事的人是很少的，然而他们最可耻的就是这点，做了荡妇却还要立贞节牌坊，这就实在是让人难以下咽了。</p>
<p>在做公众号以前我是非常讨厌那些标题党的，不过在你亲身体验之后，开始慢慢理解了，毕竟吸粉太困难了，不靠内容、不靠标题、不靠噱头根本得不到用户的关注啊，在新增用户已经很少的情况下，每天还有大量的人取消关注，你甚至都开始怀疑人生了，如果我直接推送毛片是不是可以得到更多的关注呢？当然了，这是不可取的，我想表达的是，在互联网这个充斥这垃圾信息的世界，尤以今日头条为最，几乎全是垃圾信息，想要让优质内容触达每位用户是非常难的，这也正是微信的难题，所以微信也在不断变化，从支持原创，到转载原创内容变成分享模式，都是在鼓励原创，也是想让更多优质的原创内容直达用户。</p>
<h4 id="房子"><a href="#房子" class="headerlink" title="房子"></a>房子</h4><p>房子这个话题，是每个人都躲不开的，不管你是耄耋之年还是弱冠之年，房子都是一个迈不过的坎，也许你会说，对于那些即将入土的人了，还有必要考虑房子吗？少年啊，你还是too young，too simple啊，君未见最近国家开始推动以房养老了吗？其实国家的算盘也很简单，让每个人都背负着一生的房贷，穷尽毕生之力创造的财富，都不过是为银行打工为国家打工罢了。现在倒好，国家的上层人士真是人才辈出啊，你以为你打了一辈子的工可以传给子女一套房子，太天真了，现在来个以房养老，让你在死的时候再把房子还给国家，这真真的是来也空空，去也空空啊，白白在世间劳累一生，也许有人说你太以小人之心度国家之腹了，呵呵，我倒也希望是呢，这样毕竟我错了，那么国民可以幸福，罢特（But）现实总是这么残酷，不论你信也罢不信也罢，它就在那里，不悲不喜、不来不去、不增不减、不舍不弃。有兴趣的可以去看看<a href="https://github.com/programthink/zhao" target="_blank" rel="external">《太子党关系网络》</a>，多少大公司都掌握在私人手里，多少财富都进了私人腰包，从这个关系网里，我还学到了一点，一定要多生孩子，你看看那些只有一个孩子的开国牛人们，其关系网多么形单影只啊，就一条直线发展下去，反观那些子女多的，关系网密密麻麻，势力庞大无比，还可以与其它强大的家族联姻，结果是一代更胜一代。看完真的是心痛啊，用鲁迅的话说，就是哀其不幸，怒其不争，现在的愚民们依然逃不过这句话。</p>
<p>其实并不是少数人有此想法，现在可以说部分有识之士已经看出了国家的企图，根据他们的分析，我先抛出结论，那就是赶紧买房。何来此说，大城市的的房价压的人喘不过气来，其实方法很简单，敞开土地供应即可，不是有好多人抢房子吗？还有好多屯房子的？那就让他屯让他抢，只要土地敞开供应，房价绝不会涨到现在这个地步的。那么为什么有利于人民的好事总是无法实现呢？因为土地财政啊，同志们，国家卖了几十年的房子，现在已经发现一个问题了，国家开始后悔了，为什么？因为土地卖的太便宜了。你说现在的房价已经上天了，为什么还说土地卖便宜了呢？且慢，土地和房价并不能简单的挂钩的，土地卖的是七十年使用权，而价钱是在土地出让的时候一次性收取，把时间线拉长了来看，这七十年只要货币随便贬点值，随便多印点钞票，国家就会发现自己亏了，土地卖贱了，所以现在开始大力鼓吹什么租售同权，这样从长远来看，房租每年都可以涨，国家现在直接放弃一锤子买卖，可以大摇大摆的拼命印钞了，货币贬值了，不怕，我涨房租就是了，反正我不会亏。那倒霉的是谁呢？就是普通的老百姓，从总价来算，租七十年的房子最后付出的金钱一定是比买一套七十年产权的房产要多的。你以为租售同权了，你就不用买房了？用一些有识之士的人的话说就是，你们就是等着被收割的韭菜，还有大量的智商税都是向你们这些人收的，这才得出了我一开始就抛出的结论，有钱赶紧买，现在就买，否则你真的会租一辈子房子的。</p>
<h4 id="摩拜-VS-OFO"><a href="#摩拜-VS-OFO" class="headerlink" title="摩拜 VS. OFO"></a>摩拜 VS. OFO</h4><p>为什么谈这个话题，只因为朱啸虎和马化腾在朋友圈互怼，火爆了整个互联网圈子。如果就短期来看的话，OFO是有机会吞并摩拜的，为什么这么说，因为在短期如果有合并事件发生的话，那么由于OFO的铺货量远超摩拜，再加上OFO的假订单数量远超摩拜（假订单指的是我在家不动，一天就能用OFO刷个十几二十单，而摩拜则完全无法刷单），会给予投资人一种假象，认为OFO的市场占有率超过摩拜，进而在合并两者的时候给予OFO更大的估值。但是同样地，拉长时间战线，摩拜一定是最后的胜者，不光源于摩拜过硬的整车质量，以及一些细节都让我非常欣喜。比如摩拜的后齿轮链条两边是有凸起的塑料包裹，这样可以防止掉链子，还有摩拜的车筐设计，是固定在前管(<a href="http://www.qixing365.com/juhe/65260.html" target="_blank" rel="external">头管</a>)上，而不是车把手上，这样车筐不会随着把手的转向而左右晃动。摩拜这些贴心的细节设计，树立了一个有追求企业的标杆，反观OFO呢？垃圾的一塌糊涂，虽说OFO的车身重量比摩拜轻，但是亲身体验之后发现，OFO骑起来比摩拜重多了，这就是质量的价值。除此之外，OFO的车身设计几乎没有值得称道的地方，满大街的OFO，扫过十辆几乎有一半是坏的，即便现在OFO换掉了哑终端，换上了号称有自主研发技术的智能锁，那也是和摩拜无法相提并论的，摩拜依靠太阳能（车筐底部的黑色太阳能板）和用户骑行的动力（有些人反馈摩拜重就源于此）来给智能锁充电，而OFO居然恬不知耻的也说自己的是智能锁，其实OFO的锁中是依靠纽扣电池提供动力的，而这些纽扣电池的电量最多维持两年左右，所以两年之后，不仅满大街都是坏的OFO，还有满大街的扫了毫无反应的OFO了。</p>
<p>对于长期的发展而言，我更加看好摩拜。如果我预言错误，欢迎您回来留言打脸，这锅我背。遥想当年，晋惠帝的那句<a href="https://baike.baidu.com/item/%E4%BD%95%E4%B8%8D%E9%A3%9F%E8%82%89%E7%B3%9C" target="_blank" rel="external">“何不食肉糜”</a>，现在的投资人也几乎到了同样的地步，他们不去街头巷尾亲身体验一下摩拜和OFO的真实差距，只知道坐在高楼大厦里看数据，殊不知，数据也是完全可以造假的。其实还可以进一步引申，那就是阶级分层，因为顶层的人士现在已经完全和底层的人脱节了，他们无法了解底层的人的真实生活情况。朱啸虎说，OFO的订单量超过摩拜，OFO的投放量超过摩拜，在街头的OFO数量超过摩拜，我只想说，你个二傻子，当你扫了十辆OFO有一半坏的时候，你最想做的是看到一辆OFO砸一辆，而不是投资了。</p>
<h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><p>最初了解到比特币是在2013年，当时也是偶然看到，但是只研究了一天，发现个人挖矿的机会已经消失，剩下是专业矿机和矿池的天下了，所以果断的放弃了，现在想来实在可惜，虽然挖不到了，但是我可以买啊，而之所以没有投资，就是没有敏锐的察觉到比特币会涨成今天这个样子。刚查了一下，2013年8月时候是108美元/BTC，而现在的价格是3800美元/BTC，一个百万富翁的机会就这样错失了，简单算下，一枚净赚3700美元的话，折合24400元人民币，那想获利一百万，只需要持有41个BTC左右。但是今天我想说的并不是回首往昔，空余嗟叹，而是比特币是无法成为合法货币的。</p>
<p>现在的币圈已经火得如楼市一般了，再加上<a href="https://zh.wikipedia.org/zh-hans/%E9%A6%96%E6%AC%A1%E4%BB%A3%E5%B8%81%E5%8F%91%E5%94%AE" target="_blank" rel="external">ICO</a>项目的加持，大量资金汇集而来，不管是投资者还是投机者，在这场ICO的盛宴中，他们都是可怜的散户。ICO的本质就是一场赌局，一场零和博弈。而据我所知，多数人的脑子已经烧到了对风险视而不见的地步了，这本不是什么高深的骗局，但面对巨大的诱惑，几十枚就能达到百万富翁的地步，许多人已经是对风险不管不顾了，就算是骗局，也要博上一把。不管是BTC还是其它任何Coin其本身都是无法产生任何价值的，当然会有人站出来说，我用它做为支付媒介了，这就是它的价值啊，可是在现在的币圈，基本上98%的交易都是为了投机而已，而并不是实实在在的因商业贸易而做的交易。另一方面，任何一个合法的政府都不会让BTC成为合法的货币，印钞票是政府获得财政收入的最大手段，也是政府用来制造通胀进而剥削全体国民的最有效有段，这不仅是执政之基，也是立国之本，当货币的发行权不掌握在自己手中，并且这个货币还是无法通胀的时候，任何不需要有脑子的政府也知道，是绝不可能让它成为合法货币的，最多是合法交易而已。</p>
<p>我从来不反对投资，自然也不反对投机，只是愿赌服输，不要让国家兜底，或者说不要像那些傻逼炒房族在房价下跌之后去打砸售楼处一样，这种粗俗智商低劣的行为我是很看不惯的，堂堂中华上下五千年，自古买定离手，而你在炒房之后，赫然发现房价下跌进而打砸售楼处，这得是多么恶心的人才能干的事啊。那如果我大中国13亿人都在买定东西之后，发现东西有任何降价行为都去打砸超市、菜市场、商场等等，那画面太美，我不敢想。我对投机是没有任何偏见的，投机的世界一定是个零和博弈的世界，有的人赚就一定有人亏，而前提是每个人都是自愿并且抱着对未来的美好愿景而入局的，那就只能靠自己的实力各安天命吧，还是那句话，即便你输了，也要维持人品这个最低的道德底线，因为你是人，不是畜生。</p>
<h4 id="中印对峙"><a href="#中印对峙" class="headerlink" title="中印对峙"></a>中印对峙</h4><p>为什么要谈这个事呢？主要是鲁迅已逝，但是阿Q重生，让我不得不说。不论是公众号还是简书任何允许自由发声的世界里，我都发现脑残居多，真正有智慧的人总是处于数量上的劣势。谈中印对峙主要是因为印度撤军而起，在维基百科上<a href="https://zh.wikipedia.org/wiki/2017%E5%B9%B4%E4%B8%AD%E5%8D%B0%E5%86%9B%E9%98%9F%E6%B4%9E%E6%9C%97%E5%AF%B9%E5%B3%99%E4%BA%8B%E4%BB%B6" target="_blank" rel="external">2017年中印军队洞朗对峙事件</a>说的清清楚楚，中印对峙是因为印度入侵了中国的洞朗地区而起，在印度主动撤军之后，中国的阿Q党们群起而攻之，比如有说“阿三怕了，吓跑了”、“印度阿三认输了”、“印度服软了，扛不住了”、“阿三怂了”、“阿三再张狂，也得灰溜溜走了”……</p>
<p>这些人都是什么心态啊，人家入侵你的国家，你就一顿嘲讽？人家入侵你的国家，只是撤退了而已，你就说人家怕了？人家入侵你的国家，只是回到了入侵之前的状态而已，你就说人家怂？本身而言，印度撤军当然值得庆贺，说明我国强大，但是我不希望你们都是一群阿Q党，这就像比如有人跑到你家院子里，然后一顿打砸，最后走了，你在那拍拍手，说，“嘻，吓跑了吧”，那我也是服你的。</p>
<p>抛开这事不谈，在其它方面，中国也远远不够强硬。中国和印度有领土争端，但是争议领土在印度手里（藏南地区）；中国和日本有领土争端，但是争议领土在日本手里（钓鱼岛），中国和越南有领土争端，但是争议领土在越南手里（南沙群岛、西沙群岛）；中国和菲律宾、文莱、马来西亚有领土终端，但是争议领土同样不在中国手里（南沙群岛、黄岩岛）；其它还有很多就不一一列举。总之我知道，俄罗斯和任何国家有领土终端，那么争议领土一定在俄罗斯手里，还有远东地区，被俄罗强占，现在倒好，开采油气转手卖给中国，躺着都赚钱。都说中国人民是世界上最勤劳最辛苦的人民，中国有这么多的阿Q党，不辛苦天理何在呢？中国还远远不够强大，至少就拿老祖宗给我们留的国土来说，近两百年丢了太多太多……</p>
<h4 id="金融杠杆"><a href="#金融杠杆" class="headerlink" title="金融杠杆"></a>金融杠杆</h4><p>加杠杆，没什么好说的，我是举双手赞成的。现在通胀这么厉害，加杠杆是对抗通胀的一种利器。只要能有机会加杠杆的，一定要加上，那么说到底，买房其实也是一种加杠杆行为，比如你首付一百万，买了个三百万的房子，你本身是没有另外两百万的，但是你依然撬动了三百万的房子，这就是加杠杆行为。买房的人都赚钱了，这是肯定的，试想你用一百万，撬动了三百万的资金，即使你不买房子，你去干任何事情，都是有机会赚钱的，这本身的逻辑是完全正确的，买房赚钱的本质不是因为买房，而是你动用了杠杆，另外还有就是通胀，钱越来越多，钞票越来越毛，房价自然涨。</p>
<h4 id="知识服务"><a href="#知识服务" class="headerlink" title="知识服务"></a>知识服务</h4><p>谈知识服务就必然要谈得到，因为罗振宇是中国的知识服务商们的执牛耳者。就我个人而言，听了得到上面的很多音频，不管是读书系列，还是订阅系列，亦或者罗振宇自己主讲系列，都有很多谬误，我希望你们把得到作为一种获取知识的渠道，而不是圣经，以为他讲什么都是对的，他讲什么都是有道理的，这是不然的。就本质来讲，罗振宇是个商人，商人自然就要盈利，他不是布道师，也不是来民间义务为你们开智的天使，其实他自己也坦言，他所做一切节目，所搞的一切社群活动的最终目的就是为了赚钱，然而他的特殊之处仅仅在于他不是卖普通的商品，而是卖知识罢了，毕竟在这个脑残盛行的时代、在这个已经很少有人愿意读书的时代、在这个垃圾信息泛滥的时代，能坚持把知识做下去，在成年人当中引领者一股读书的风潮是值得称贺的。</p>
<p>我引用一段知乎上的用户回答</p>
<blockquote>
<p>有一期，说北伐军进入南京的时候轮奸了领事夫人，青龙刀杀了领事。这个段子是林思云写的《真实的汪精卫》，而且已经在当时辟谣说是误传了。我给罗振宇发了邮件，他的制片人邮件，他的微博私信，都没有回应。看来，对历史的严谨，他们节目差太多了。——刘三叔</p>
<p>逻辑思维最好听的就是写历史故事，这些玩意也是他们扒的别人写的书，例如多次引用张宏杰先生的书，甚至连语气和修辞都照搬，原创性几乎为零。但是我们把这个节目定义成打发时间的节目，只要听别人讲故事就够了嘛。所以还是可以接受的。但是一旦开始讲道理，就只能呵呵笑了。因为太傻叉了。逻辑思维每一期都想要讲个道理，或者给你什么启示，你一旦听他总结，就觉得我靠这人什么脑子。——改之理zcw</p>
<p>罗振宇是一个媒体人，不是个学者，所以他的节目内容，多是结合热门事件，糅合社科观点的大杂烩。具有传播宣传效果，是为了吸引观众，但大多并不值得推敲。同理可证，相亲节目不是用来相亲的。——陈新</p>
</blockquote>
<p>别的我就不多说了，逻辑思维中的错误很多，而且已经越来越多的人开始觉醒了，他们开始思考，开始质疑，发现得到上的知识很多也不过都是一家之言罢了，所谓的知识服务，也就是东拼西凑拼书而已。有时候好多想法在我脑子里慢慢诞生，但是偶然在一本书或者一篇文章中或者其他的某个地方，又与有同样想法的人不期而遇，真是不觉击节赞叹，英雄所见略同啊。</p>
<h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>我这人有一个坏习惯，做事总想做到完美，所以把《阿里巴巴Java开发手册》经常放在手边，不时翻看，对应地，在现实的开发世界中，总想把东西做到在我当前水平内的最优，这必然导致几个结果，其一，领导不知，因为代码写的烂和好，功能都能够实现，根本没人关注你代码写的多漂亮，耦合度有多低，扩展有多方便，他们只关注功能是否按时上线，这导致我做了大量的幕后工作，但是并没有得到应有的回报。另一个就是前期很多人都是草草开发，力求尽快上线即可，后期当用户量上来了或者系统的各种瓶颈出现的时候，再力求优化或者重构，这样居然能获得公司的团队激励奖励，为公司的某某产品重构，性能提升了多少，BUG解决了多少，我真是呵呵了，尼玛，这不都是你们当年埋下的吗。</p>
<p>我现在真的是越来越理解比尔·盖茨当年的全员持股是多么牛逼的壮举了，因为就现在来说，多数人并不把公司的命运、前景、发展与个人利益直接挂钩，对他们来说，这个公司是明天倒闭还是二十年之后倒闭，真的差别不大，多数人的唯一目标就是当一天和尚撞一天钟，什么时候这个钟坏了或者说再也撞不了了，那么我换一个钟，继续当一天和尚撞一天钟即可。所以就我了解的开发而言，多数人都是不合格的，更不用谈那些培训机构出来的了，简历公然造假居然都不以为意，被那些培训机构里完全以挣钱为目的的老师教出来的学生，其核心价值观我真的很怀疑。</p>
<h4 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h4><p>现在的社会，如果你有能力加杠杆，那就不要客气，但是如果你没有这个能力，那就一定要学会理财，俗话说，你不理财，财不理你。农村的很多人真是辛苦一辈子，最后一夜回到解放前，当然这只是个比喻的说法，因为他们没有任何金融方面的知识，只知道把钱存在银行，包括我父母也是这样，虽然我父母并没有多少钱可以存，但是不论多寡，只要放在银行中，你就是亏本的，而你亏的钱就是通胀利率减去银行利率再乘以本金，可怜中国的老百姓，每当我看到他们辛苦攒钱都是莫名的心痛，你攒的这一点点钱，国家随便印个钞票都给你通胀掉了。</p>
<p>从毕业到现在我已经存了二十万了，钱虽不多，但是这是我从无到有，白手起家，一点点积累而来，和那些含着金钥匙出生的人自然无法相提并论，不用说富二代官二代了，光是普通的上海土著，碾压我都没有丝毫压力，但是如果真正的拼个人，而不是拼父母，不是拼上一代，我想我也并不输他们多少吧。</p>
<p>我的多数资产都在投资P2P，目前在投的有七八个平台吧，期间也玩过黄金，薅过羊毛，还有就是少量的公众号的收入，虽然微不足道，但是积少成多，集腋成裘啊，你一个山里出来的人，没有任何人可以指望的上，我想我能做的也只有这么多了吧。前路漫漫，我始终坚信互联网的世界里还是有很多机会的，哪怕你只要抓住一次，就有机会翻身，这也导致我在当年校招的时候，嚣张的和HR说，我只去互联网公司，只要一直浸淫在这个行业中，总会有机会的，希望我不要被自己打脸吧，然后啥机会也没抓住，那就丢人了。现在虽然辛苦，但是为了更好的下一代，为了父母老有所依、老有所养，我别无他路，只能躬身前行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;楔子&quot;&gt;&lt;a href=&quot;#楔子&quot; class=&quot;headerlink&quot; title=&quot;楔子&quot;&gt;&lt;/a&gt;楔子&lt;/h4&gt;&lt;p&gt;好久没有发文了，最近有价值的技术总结并不多，或者说，已经懒的去总结技术了，毕竟这事也挺耗费时间与精力的。虽说初衷是为了避免无病呻吟，结果却导
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Byteman 使用教程</title>
    <link href="http://www.codepub.cn/2017/09/22/byteman-uses-tutorials/"/>
    <id>http://www.codepub.cn/2017/09/22/byteman-uses-tutorials/</id>
    <published>2017-09-22T13:50:38.000Z</published>
    <updated>2017-11-20T14:18:34.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Byteman简介"><a href="#Byteman简介" class="headerlink" title="Byteman简介"></a>Byteman简介</h3><p>Byteman由JBoss出品，JBoss大家应该都熟悉，顶顶大名的应用服务器JBoss也出自其手。Byteman的代码插入能力相比BTrace而言更强，似乎可以在代码中任意的位置插入我们的跟踪代码（当然，你可能需要对Java代码生成、字节码技术有一定的了解），以及访问当前方法中变量的能力（包括方法参数、局部变量、甚至于调用其它函数的参数值、返回值等），而BTrace在这方面的能力要弱很多。</p>
<h3 id="安装Byteman"><a href="#安装Byteman" class="headerlink" title="安装Byteman"></a>安装Byteman</h3><p>首先去<a href="http://byteman.jboss.org/downloads.html" target="_blank" rel="external">官网</a>下载最新的压缩包，解压，配置环境变量，开始操练，老熟悉了。新建<code>BYTEMAN_HOME</code>值是<code>E:\byteman-3.0.10</code>，编辑<code>Path</code>环境变量，在末尾添加<code>;%BYTEMAN_HOME%/bin</code>，打开cmd，输入<code>bminstall</code>验证一下</p>
<blockquote>
<p>usage: bminstall [-p port] [-h host] [-b] [-s] [-m] [-Dname[=value]]* pid<br>  pid is the process id of the target JVM<br>  -h host selects the host name or address the agent listener binds to<br>  -p port selects the port the agent listener binds to<br>  -b adds the byteman jar to the bootstrap classpath<br>  -s sets an access-all-areas security policy for the Byteman agent code<br>  -m activates the byteman JBoss modules plugin<br>  -Dname=value can be used to set system properties whose name starts with “org.jboss.byteman.”<br>  expects to find a byteman agent jar and byteman JBoss modules plugin jar (if -m is indicated) in BYTEMAN_HOME</p>
</blockquote>
<h3 id="使用示例（读取局部变量）"><a href="#使用示例（读取局部变量）" class="headerlink" title="使用示例（读取局部变量）"></a>使用示例（读取局部变量）</h3><p>为什么选择这个示例呢？因为BTrace无法追踪到局部变量的值，那么为了显示Byteman的强大，必须让它做别人做不到的事。首先编写一个待追踪的示例，这个例子很简单，接收用户的输入内容，并原样输出即可，如果输入中包含end，那么程序自动结束，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.DataInputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BytemanDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> BytemanDemo().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(System.in);</div><div class="line">            BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String next = buf.readLine();</div><div class="line">                <span class="keyword">while</span> (next != <span class="keyword">null</span> &amp;&amp; !next.contains(<span class="string">"end"</span>)) &#123;</div><div class="line">                    consume(next);</div><div class="line">                    next = buf.readLine();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">        <span class="comment">//这是个局部变量，将会在byteman中追踪她</span></div><div class="line">        <span class="keyword">final</span> String arg = text;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"program confirm "</span> + arg));</div><div class="line">        thread.start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            thread.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，启动程序测试一下</p>
<blockquote>
<p><em>byteman test demo</em><br>program confirm byteman test demo</p>
</blockquote>
<p>那么试想一下，如果程序输出的和我们输入的总是不同，会不会是consume方法中出现了Bug呢？那么如果想要确认传入到consume方法中的参数是否正确要怎么做呢？所以这时候就需要在byteman中读取consume方法中的局部变量<code>arg</code>了。</p>
<p>首先加载byteman到JVM中，并将它attach到需要监听的进程上，指定byteman监控程序监听55000端口（这个端口是用来对byteman的脚本进行响应的）<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">wangxu</span>&gt;<span class="title">jps</span></span></div><div class="line">18592 <span class="title">Jps</span></div><div class="line">20068 <span class="title">AppMain</span></div><div class="line">8584</div><div class="line">18668 <span class="title">Launcher</span></div><div class="line"></div><div class="line"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">wangxu</span>&gt;<span class="title">bminstall</span> -<span class="title">b</span> -<span class="title">Dorg.jboss.byteman.transform.all</span> -<span class="title">Dorg.jboss.byteman.verbose</span> -<span class="title">p</span> 55000 20068</div></pre></td></tr></table></figure></p>
<p>再回到被监控程序的控制台看到如下输出</p>
<blockquote>
<p><em>byteman test demo</em><br>program confirm byteman test demo<br>Setting org.jboss.byteman.transform.all=<br>Setting org.jboss.byteman.verbose=<br>TransformListener() : accepting requests on localhost:55000</p>
</blockquote>
<p>从输出信息中可以看到，byteman监听55000端口，并在该端口接收请求，那就来请求一把呗，打开编辑器，编写byteman的btm脚本，ShowLocalVar.btm，如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RULE trace line local var</div><div class="line"></div><div class="line">CLASS BytemanDemo</div><div class="line">METHOD consume(String)</div><div class="line">AFTER WRITE $arg</div><div class="line"></div><div class="line">IF TRUE</div><div class="line">        DO traceln("*** transfer value is : " + $arg + " ***")</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>接下来就安装脚本吧，运行bmsubmit提交脚本</p>
<blockquote>
<p>C:\Users\wangxu&gt; bmsubmit -p 55000 -l ShowLocalVar.btm<br>install rule trace line local var</p>
</blockquote>
<p>再回到被监控程序的控制台，输入一段测试语句”byteman test demo2”查看输出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">TransformListener() : handling connection on port 55000</div><div class="line">retransforming BytemanDemo</div><div class="line">org.jboss.byteman.agent.Transformer : possible trigger for rule trace line local var in class BytemanDemo</div><div class="line">RuleTriggerMethodAdapter.injectTriggerPoint : inserting trigger into BytemanDemo.consume(java.lang.String) void for rule trace line local var</div><div class="line">org.jboss.byteman.agent.Transformer : inserted trigger for trace line local var in class BytemanDemo</div><div class="line">byteman test demo2</div><div class="line">Rule.execute called for trace line local var_0</div><div class="line">HelperManager.install for helper class org.jboss.byteman.rule.helper.Helper</div><div class="line">calling activated() for helper class org.jboss.byteman.rule.helper.Helper</div><div class="line">Default helper activated</div><div class="line">calling installed(trace line local var) for helper classorg.jboss.byteman.rule.helper.Helper</div><div class="line">Installed rule using default helper : trace line local var</div><div class="line">trace line local var execute</div><div class="line">*** transfer value is : byteman test demo2 ***</div><div class="line">program confirm byteman test demo2</div></pre></td></tr></table></figure></p>
<p>可以看到星号打头和结尾的那一句，就是监控程序从被监控程序中得到的局部变量，是不是很强大啊。</p>
<p>当然了可以安装脚本，就可以卸载脚本，同样是使用bmsubmit命令</p>
<blockquote>
<p>C:\Users\wangxu&gt; bmsubmit -p 55000 -u ShowLocalVar.btm<br>uninstall RULE trace line local var</p>
</blockquote>
<p>卸载完成之后，再回到被监控程序的控制台，输入测试语句<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TransformListener() : handling connection on port <span class="number">55000</span></div><div class="line">retransforming BytemanDemo</div><div class="line">HelperManager.uninstall <span class="keyword">for</span> helper class org.jboss.byteman.rule.helper.Helper</div><div class="line">calling uninstalled(trace line local var) <span class="keyword">for</span> helper class org.jboss.byteman.rule.helper.Helper</div><div class="line">Uninstalled rule using default helper : trace line local var</div><div class="line">calling deactivated() <span class="keyword">for</span> helper classorg.jboss.byteman.rule.helper.Helper</div><div class="line">Default helper deactivated</div><div class="line">byteman test demo3</div><div class="line">program confirm byteman test demo3</div></pre></td></tr></table></figure></p>
<p>可以看到程序又回到了最初的摸样，这种完全无侵入式的设计真是太完美了，对于需要被监控的程序来说几乎是透明的，它不需要做任何改变，我们就可以通过动态追踪技术得到我们感兴趣的信息，而且在追踪结束后卸载脚本，被监控程序依然还是最初的摸样。</p>
<p>注意点：我的被监控程序是在IDEA中运行的，也就是说，IDEA会自动帮我编译源码，我只需要运行即可，那么如果你是使用命令行自己编译的Java源码，很可能无法追踪到局部变量的值，这是因为自己编译的话，需要指定<code>-g</code>参数，也就是像这样<code>javac -g Byteman.java</code>编译出来的class文件才能够被追踪到局部变量。对细节感兴趣的话请看<a href="https://developer.jboss.org/thread/176913" target="_blank" rel="external">这里</a>。</p>
<h3 id="使用示例（统计方法耗时）"><a href="#使用示例（统计方法耗时）" class="headerlink" title="使用示例（统计方法耗时）"></a>使用示例（统计方法耗时）</h3><p>与上例不同，这个例子主要展示如何使用<code>bmjava</code>和<code>bmcheck</code>这两个命令。先上待追踪代码，很简单的例子，working方法模拟工作方法，我们通过动态追踪获得工作方法花费的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.DataInputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        WorkerDemo workerDemo = <span class="keyword">new</span> WorkerDemo();</div><div class="line">        DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(System.in);</div><div class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(dataInputStream));</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String next;</div><div class="line">            <span class="keyword">while</span> ((next = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"before working"</span>);</div><div class="line">                workerDemo.working();</div><div class="line">                System.out.println(<span class="string">"after working"</span>);</div><div class="line">                <span class="keyword">if</span> (next.contains(<span class="string">"end"</span>)) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写byteman脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">RULE trace worker time start</div><div class="line"></div><div class="line">CLASS WorkerDemo</div><div class="line">METHOD working</div><div class="line">AT ENTRY</div><div class="line"></div><div class="line">IF TRUE</div><div class="line">DO createTimer($0)</div><div class="line">ENDRULE</div><div class="line"></div><div class="line">RULE trace worker time stop</div><div class="line"></div><div class="line">CLASS WorkerDemo</div><div class="line">METHOD working</div><div class="line">AT EXIT</div><div class="line"></div><div class="line">IF TRUE</div><div class="line">DO traceln("*** working time " + getElapsedTimeFromTimer($0) + " ms ***");</div><div class="line">    deleteTimer($0);</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>注意一点，在规则脚本中用到的方法<code>createTimer</code>，<code>getElapsedTimeFromTimer</code>，<code>deleteTimer</code>都是在<code>org.jboss.byteman.rule.helper.Helper</code>类中定义好的，并且在创建Timer之后，一定要记得删除，这里面方法的形参必须要从0开始，感兴趣的可以看看这几个方法的详细说明</p>
<ul>
<li><strong>createTimer</strong> can be called to create a new Timer associated with o. createTimer returns true if a new<br>Timer was created and false if a Timer associated with o already exists.</li>
<li><strong>getElapsedTimeFromTimer</strong> can be called to obtain the number of elapsed milliseconds since the Timer<br>associated with o was created or since the last call to resetTimer. If no timer associated with o exists a<br>new timer is created before returning the elapsed time.</li>
<li><strong>resetTimer</strong> can be called to zero the Timer associated with o. It returns the number of seconds since the<br>Timer was created or since the last previous call to resetTimer If no timer associated with o exists a<br>new timer is created before returning the elapsed time.</li>
<li><strong>deleteTimer</strong> can be called to delete the Timer associated with o. deleteTimer returns true if a new Timer<br>was deleted and false if no Timer associated with o exists.</li>
</ul>
<p>将WorkerDemo类和规则脚本置于同一目录下，打开cmd运行命令行，先检查一下规则脚本是否合法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;bmcheck -cp . -v TimeTracer.btm</div><div class="line">Checking rule trace worker time start against class WorkerDemo</div><div class="line">Parsed rule &quot;trace worker time start&quot; for class WorkerDemo</div><div class="line">Type checked rule &quot;trace worker time start&quot;</div><div class="line"></div><div class="line">Checking rule trace worker time stop against class WorkerDemo</div><div class="line">Parsed rule &quot;trace worker time stop&quot; for class WorkerDemo</div><div class="line">Type checked rule &quot;trace worker time stop&quot;</div><div class="line"></div><div class="line">TestScript: no errors</div></pre></td></tr></table></figure>
<p><code>bmcheck</code>命令可以在应用规则脚本之前对其进行检查，<code>bmcheck [-cp classpath]* [-p package]* [-v] script1 . . . scriptN</code>，如果是带包名的类，那么需要使用<code>-p</code>参数即可。</p>
<p>再将脚本和程序一起启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;javac -g WorkerDemo.java</div><div class="line"></div><div class="line">C:\Users\wangxu&gt;bmjava -l TimeTracer.btm WorkerDemo</div><div class="line">trace working time demo</div><div class="line">before working</div><div class="line">*** working time 5003 ms ***</div><div class="line">after working</div><div class="line">trace end</div><div class="line">before working</div><div class="line">*** working time 5000 ms ***</div><div class="line">after working</div></pre></td></tr></table></figure></p>
<p>这样操作有一个限制，就是无法追踪已经启动了的程序，如果已经有个程序正在运行，而这时候程序的输出与我们预期的不符，如何用脚本来追踪呢？这时候需要用到<code>bminstall</code>和<code>bmsubmit</code>命令。首先就按最普通的方式启动程序再说</p>
<blockquote>
<p>C:\Users\wangxu&gt;java WorkerDemo</p>
</blockquote>
<p>再开一个cmd命令行，先把byteman attach到需要追踪的进程上，再提交规则脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;jps</div><div class="line">11724</div><div class="line">1468 Jps</div><div class="line">17308 WorkerDemo</div><div class="line">5948 Launcher</div><div class="line">C:\Users\wangxu&gt;bminstall -b -Dorg.jboss.byteman.tranform.all 17308</div><div class="line"></div><div class="line">C:\Users\wangxu&gt;bminstall -b -Dorg.jboss.byteman.tranform.all 17308</div><div class="line"></div><div class="line">C:\Users\wangxu&gt;bmsubmit -l TimeTracer.btm</div><div class="line">install rule trace worker time start</div><div class="line">install rule trace worker time stop</div></pre></td></tr></table></figure></p>
<p>这时候再回到启动程序的命令行，可以看到有新的输出</p>
<blockquote>
<p>Setting org.jboss.byteman.tranform.all=</p>
</blockquote>
<p>我们输入一行测试语句试一下，看看规则脚本是否生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;java WorkerDemo</div><div class="line">Setting org.jboss.byteman.tranform.all=</div><div class="line">trace working time demo2 and then end</div><div class="line">before working</div><div class="line">*** working time 5007 ms ***</div><div class="line">after working</div></pre></td></tr></table></figure></p>
<p>使用这种方式就可以动态的追踪已经启动的程序了。</p>
<h3 id="Byteman脚本介绍"><a href="#Byteman脚本介绍" class="headerlink" title="Byteman脚本介绍"></a>Byteman脚本介绍</h3><p>首先了解byteman的脚本结构，如下所示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> Example Rule Set</span></div><div class="line"><span class="meta">#</span><span class="bash"></span></div><div class="line"><span class="meta">#</span><span class="bash"> a single rule definition</span></div><div class="line">RULE example rule</div><div class="line"><span class="meta">#</span><span class="bash"> comment line <span class="keyword">in</span> rule body</span></div><div class="line">. . .</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>其中合法的规则事件可以是如下这些<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> rule skeleton</span></div><div class="line">RULE &lt;rule name&gt;</div><div class="line">CLASS &lt;class name&gt;</div><div class="line">METHOD &lt;method name&gt;</div><div class="line">BIND &lt;bindings&gt;</div><div class="line">IF  &lt;condition&gt;</div><div class="line">DO  &lt;actions&gt;</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>同样全部的合法定位点或者说注入点如下所示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">AT ENTRY</div><div class="line">AT EXIT</div><div class="line">AT LINE number</div><div class="line">AT READ [type .] field [count | ALL ]</div><div class="line">AT READ $var-or-idx [count | ALL ]</div><div class="line">AFTER READ [ type .] field [count | ALL ]</div><div class="line">AFTER READ $var-or-idx [count | ALL ]</div><div class="line">AT WRITE [ type .] field [count | ALL ]</div><div class="line">AT WRITE $var-or-idx [count | ALL ]</div><div class="line">AFTER WRITE [ type .] field [count | ALL ]</div><div class="line">AFTER WRITE $var-or-idx [count | ALL ]</div><div class="line">AT INVOKE [ type .] method [ ( argtypes ) ] [count | ALL ]</div><div class="line">AFTER INVOKE [ type .] method [ ( argtypes ) ][count | ALL ]</div><div class="line">AT SYNCHRONIZE [count | ALL ]</div><div class="line">AFTER SYNCHRONIZE [count | ALL ]</div><div class="line">AT THROW [count | ALL ]</div><div class="line">AT EXCEPTION EXIT</div></pre></td></tr></table></figure></p>
<p>更多更详细的信息可以去参考Byteman的官方手册。也许你注意到了，在脚本中我们使用了traceln语句，那么这个调用的其实是Byteman的<code>org.jboss.byteman.rule.helper.Helper</code>类的方法，这些方法都是已经内置的，可以直接在脚本中调用。</p>
<p>当然了如果你觉得这些内置的方法不够用，也可以使用自定义的Helper类，例如官方给出的一个例子是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> helper example 2</span></div><div class="line">RULE help yourself but rely on others</div><div class="line">CLASS com.arjuna.wst11.messaging.engines.CoordinatorEngine</div><div class="line">METHOD commit</div><div class="line">HELPER HelperSub</div><div class="line">AT ENTRY</div><div class="line">IF NOT flagged($this)</div><div class="line">DO debug("throwing wrong state");</div><div class="line"><span class="meta"> flag($</span><span class="bash">this);</span></div><div class="line"> throw new WrongStateException()</div><div class="line">ENDRULE</div></pre></td></tr></table></figure></p>
<p>HelperSub的源码示例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelperSub</span> <span class="keyword">extends</span> <span class="title">Helper</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">debug</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(<span class="string">"!!! IMPORTANT EVENT !!! "</span> + message);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Byteman环境变量"><a href="#Byteman环境变量" class="headerlink" title="Byteman环境变量"></a>Byteman环境变量</h3><p>在Byteman中，总共的环境变量有如下这些</p>
<ul>
<li>org.jboss.byteman.compileToBytecode</li>
<li>org.jboss.byteman.dump.generated.classes</li>
<li>org.jboss.byteman.dump.generated.classes.directory</li>
<li>org.jboss.byteman.dump.generated.classes.intermediate</li>
<li>org.jboss.byteman.verbose</li>
<li>org.jboss.byteman.debug</li>
<li>org.jboss.byteman.transform.all</li>
<li>org.jboss.byteman.skip.overriding.rules</li>
<li>org.jboss.byteman.allow.config.updates</li>
<li>org.jboss.byteman.sysprops.strict</li>
</ul>
<p>而我们已经使用过了其中的两个，就是在bminstall命令中所示的</p>
<ul>
<li>org.jboss.byteman.transform.all 如果设置了将允许注入java.lang和其子包的class</li>
<li>org.jboss.byteman.verbose 如果设置将显示执行的各种跟踪信息到System.out，包括类型检查，编译，和执行规则</li>
</ul>
<p>有关更加详细的解释可以到<a href="http://downloads.jboss.org/byteman/3.0.10/ProgrammersGuide.html#environment-settings" target="_blank" rel="external">官方网站</a>中的<strong>Environment Settings</strong>一节查看。</p>
<h3 id="javaagent技术"><a href="#javaagent技术" class="headerlink" title="javaagent技术"></a>javaagent技术</h3><p>简单来说，javaagent 技术是一个开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。有关 javaagent 更详细的介绍，可以参看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="external">Instrumentation 简介</a>这篇文章。</p>
<h4 id="用javaagent加载规则文件并启动程序"><a href="#用javaagent加载规则文件并启动程序" class="headerlink" title="用javaagent加载规则文件并启动程序"></a>用javaagent加载规则文件并启动程序</h4><p>javaagent 选项支持在所有的个人机或服务器的JVM中使用Byteman，那么看一下如何使用 javaagent 技术来启动Byteman吧。还是以BytemanDemo为例，BytemanDemo和ShowLocalVar.btm文件都在<code>C:/Users/wangxu</code>路径下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;javac -g BytemanDemo.java</div><div class="line"></div><div class="line">C:\Users\wangxu&gt;java -javaagent:%BYTEMAN_HOME%\lib\byteman.jar=script:ShowLocalVar.btm BytemanDemo</div><div class="line">javaagent byteman demo</div><div class="line">*** transfer value is : javaagent byteman demo ***</div><div class="line">program confirm javaagent byteman demo</div></pre></td></tr></table></figure></p>
<p><code>script</code>用于指示 Byteman 规则文件的位置。Byteman agent 读取到这个选项之后从规则文件中加载和注入Byteman规则。如果要加载多个<code>script:file</code>规则文件，使用逗号（,）分隔即可。</p>
<h4 id="用javaagent启动程序并动态加载规则文件"><a href="#用javaagent启动程序并动态加载规则文件" class="headerlink" title="用javaagent启动程序并动态加载规则文件"></a>用javaagent启动程序并动态加载规则文件</h4><p>这种方式是将规则文件和需要监控的程序一起启动，那么如果被监控程序已经启动，该如何注入规则文件呢？严格执行如下步骤即可</p>
<ol>
<li>需要在启动程序的时候采用<code>java -javaagent</code>方式启动，同样地先编译<code>javac -g BytemanDemo.java</code></li>
<li><p>新开cmd，输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;java -javaagent:%BYTEMAN_HOME%\lib\byteman.jar=listener:true,boot:%BYTEMAN_HOME%\lib\byteman.jar -Dorg.jboss.byteman.transform.all BytemanDemo</div></pre></td></tr></table></figure>
<p>Linux系统只需要把<code>%BYTEMAN_HOME%</code>换成<code>${BYTEMAN_HOME}</code>即可，注意Linux上分隔符是正斜杠，这个监听器会开启一个网络监听。注意：当没有规则加载的时候，程序的的行为不会发生任何变化，仅输出我们输入的内容。这时候需要第三步来加载规则文件</p>
</li>
<li><p>新开cmd，输入<code>C:\Users\wangxu&gt;bmsubmit -l ShowLocalVar.btm</code>，cmd反馈出<code>install rule trace line local var</code>，再回到第二步的cmd窗口，输入测试语句”javaagent byteman demo2”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\Users\wangxu&gt;java -javaagent:%BYTEMAN_HOME%\lib\byteman.jar=listener:true,boot:%BYTEMAN_HOME%\lib\byteman.jar -Dorg.jboss.byteman.transform.all BytemanDemo</div><div class="line">javaagent byteman demo2</div><div class="line">*** transfer value is : javaagent byteman demo2 ***</div><div class="line">program confirm javaagent byteman demo2</div></pre></td></tr></table></figure>
<p>可以看到规则已经生效。这种方式虽然可以实现同样地监控，但是还是存在一个明显的弊端，就是要求在启动程序的时候使用<code>javaagent</code>方式，但是通常我们并不会用这种方式，大多数人都是用最普通的<code>java -jar</code>命令，那么且看下节。</p>
</li>
</ol>
<h4 id="动态安装agent到正在运行的程序中"><a href="#动态安装agent到正在运行的程序中" class="headerlink" title="动态安装agent到正在运行的程序中"></a>动态安装agent到正在运行的程序中</h4><p>如果你启动了一个长时程序，并且没有加载 Byteman agent。你不需要重启程序也可以使用 Byteman。在Byteman的bin目录下有很多脚本，Windows上的是<code>bminstall.bat</code>，Linux上的是<code>bminstall.sh</code>，由于所有线上服务器都是用的Linux，那么接下来我就在CentOS上演示一下动态安装agent技术。</p>
<p>首先编译，启动程序再说<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster ~]$ ll</div><div class="line">total 12</div><div class="line">-rw-rw-r--.  1 elastic elastic 1218 Sep 21 15:59 BytemanDemo.java</div><div class="line">drwxr-xr-x. 10 elastic elastic 4096 Aug 29 14:45 elasticsearch</div><div class="line">-rw-rw-r--.  1 elastic elastic  171 Sep 21 15:59 ShowLocalVar.btm</div><div class="line">[elastic@escluster ~]$ javac -g BytemanDemo.java</div><div class="line">[elastic@escluster ~]$ java BytemanDemo</div><div class="line">Byteman agent in linux</div><div class="line">program confirm Byteman agent in linux</div></pre></td></tr></table></figure></p>
<p>这个时候可见就是一个普通的程序，下面在Linux配置环境变量，编辑<code>/etc/profile</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BYTEMAN_HOME=/usr/program/byteman-3.0.10</div><div class="line">PATH=$PATH:$BYTEMAN_HOME/bin</div><div class="line">export BYTEMAN_HOME</div><div class="line">export PATH</div></pre></td></tr></table></figure></p>
<p>新开一个终端，按如下所示操作<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster ~]$ jps</div><div class="line">24739 Elasticsearch</div><div class="line">12215 BytemanDemo</div><div class="line">25128 Elasticsearch</div><div class="line">24874 Elasticsearch</div><div class="line">12251 Jps</div><div class="line">[elastic@escluster ~]$ bminstall.sh -b -Dorg.jboss.byteman.transform.all 12215</div><div class="line">[elastic@escluster ~]$ bmsubmit.sh -l ShowLocalVar.btm</div><div class="line">install rule trace line local var</div></pre></td></tr></table></figure></p>
<p><code>bminstall.sh</code>并没有加载任何规则脚本，只是开启了agent监听器。然后就可以通过bmsubmit.sh提交规则。在将规则脚本sumbit或者unsubmit到程序中，会看到程序的行为被动态修改了。返回到第一个终端，继续输入测试语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[elastic@escluster ~]$ java BytemanDemo</div><div class="line">Byteman agent in linux</div><div class="line">program confirm Byteman agent in linux</div><div class="line">Setting org.jboss.byteman.transform.all=</div><div class="line">Byteman agent in linux after install and submit</div><div class="line">*** transfer value is : Byteman agent in linux after install and submit ***</div><div class="line">program confirm Byteman agent in linux after install and submit</div></pre></td></tr></table></figure></p>
<p>Perfect规则生效了，无论是Windows还是Linux，Byteman都可以完美地工作。</p>
<h3 id="Byteman其它命令"><a href="#Byteman其它命令" class="headerlink" title="Byteman其它命令"></a>Byteman其它命令</h3><p>Byteman的启动方式非常多，个人精力有限，我不能一一介绍，想要了解更多的信息，直接去翻阅压缩包中的<code>docs/byteman-programmers-guide.pdf</code>用户指南，上面有详细地介绍。</p>
<p>在解压的Byteman的bin目录下，有非常多的脚本，简单介绍如下所示</p>
<ul>
<li><strong>bmcheck</strong> 在注入规则文件之前，该命令可以在线下对你的规则脚本进行解析和类型检查</li>
<li><strong>bminstall</strong> 安装agent到一个正在运行的程序中</li>
<li><strong>bmjava</strong> 该脚本包装了<code>-javaagent</code>选项。它的用法很像java命令，但是它能以<code>-javaagent script:</code>选项的方式接受Byteman规则脚本。并且自动以<code>boot:</code>的方式绑定了Byteman的Jar文件</li>
<li><strong>bmsetenv</strong> 该脚本用来设置环境，agent对配置其行为的各种环境设置非常敏感</li>
<li><strong>bmsubmit</strong> 上传和卸载规则脚本</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Byteman简介&quot;&gt;&lt;a href=&quot;#Byteman简介&quot; class=&quot;headerlink&quot; title=&quot;Byteman简介&quot;&gt;&lt;/a&gt;Byteman简介&lt;/h3&gt;&lt;p&gt;Byteman由JBoss出品，JBoss大家应该都熟悉，顶顶大名的应用服务器JBo
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Byteman" scheme="http://www.codepub.cn/tags/Byteman/"/>
    
  </entry>
  
  <entry>
    <title>BTrace 使用教程</title>
    <link href="http://www.codepub.cn/2017/09/22/btrace-uses-tutorials/"/>
    <id>http://www.codepub.cn/2017/09/22/btrace-uses-tutorials/</id>
    <published>2017-09-22T13:48:40.000Z</published>
    <updated>2017-11-20T14:18:34.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在日常开发中，有一些常见的环境，比如Dev、UAT、预发、生产等，当然并不是每个公司都是这样。有时候开发环境一切正常，但是到线上的UAT环境或预发等等会出现各种问题，那么你是不是经常需要进行本地修改代码、提交、编译、打包、上传、运行、查看日志等这一系列步骤呢？这种方式不仅低效、繁琐而且容易引入诸多不可控的因素，比如你在任意一个环节出现问题，可能都会影响到程序最终的运行结果。而如果能有一种神器，可以对正在运行的程序，进行动态追踪、错误诊断、性能剖析等，是不是无形中为你延长了生命呢？如果你之前不知道也就罢了，然而如果你看到这里了，却还不学习的话，就是你自己的锅了。</p>
<h3 id="Java运行时追踪工具"><a href="#Java运行时追踪工具" class="headerlink" title="Java运行时追踪工具"></a>Java运行时追踪工具</h3><p>常见的动态追踪工具有<a href="https://github.com/btraceio/btrace" target="_blank" rel="external">BTrace</a>、<a href="https://github.com/CSUG/HouseMD" target="_blank" rel="external">HouseMD</a>（该项目已经停止开发）、<a href="https://github.com/oldmanpushcart/greys-anatomy" target="_blank" rel="external">Greys-Anatomy</a>（国人开发，个人开发者）、<a href="http://byteman.jboss.org/" target="_blank" rel="external">Byteman</a>（JBoss出品），注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常用的，本文主要介绍BTrace。</p>
<h3 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h3><h4 id="BTrace简介"><a href="#BTrace简介" class="headerlink" title="BTrace简介"></a>BTrace简介</h4><p>BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一下BTrace的官方定义</p>
<blockquote>
<p>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program (similar to DTrace for OpenSolaris applications and OS). BTrace dynamically instruments the classes of the target application to inject tracing code (“bytecode tracing”)</p>
</blockquote>
<p>简洁明了，大意是一个Java平台的安全的动态追踪工具。可以用来动态地追踪一个运行的Java程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪”）。</p>
<p>动手之前再了解一下BTrace的主要术语</p>
<ul>
<li><strong>Probe Point</strong>: “location” or “event” at which a set of tracing statements are executed. Probe point is “place” or “event” of interest where we want to execute some tracing statements.（探测点，就是我们想要执行一些追踪语句的地方或事件）</li>
<li><strong>Trace Actions or Actions</strong>: Trace statements that are executed whenever a probe “fires”.（当探测触发时执行追踪语句）</li>
<li><strong>Action Methods</strong>: BTrace trace statements that are executed when a probe fires are defined inside a static method a class. Such methods are called “action” methods.（当在类的静态方法中定义了探测触发时执行的BTrace跟踪语句。这种方法被称为“操作”方法。）</li>
</ul>
<h4 id="安装BTrace"><a href="#安装BTrace" class="headerlink" title="安装BTrace"></a>安装BTrace</h4><p>目前，BTrace已经托管在Github上了，主页在<a href="https://github.com/btraceio/btrace" target="_blank" rel="external">这里</a>，下载地址在<a href="https://github.com/btraceio/btrace/releases" target="_blank" rel="external">这里</a>，目前最新版本是<code>V1.3.9</code>。新建环境变量<code>BTRACE_HOME</code>值为<code>E:/btrace-bin-1.3.9</code>，然后编辑<code>Path</code>变量，在值的末尾追加<code>;%BTRACE_HOME%/bin</code>即可，验证是否安装成功，打开cmd，输入btrace，显示如下则证明配置成功</p>
<blockquote>
<p>Usage: btrace <options> <pid> <btrace source="" or="" .class="" file=""> <btrace arguments=""><br>where possible options include:<br>  –version             Show the version<br>  -v                    Run in verbose mode<br>  -o <file>             The path to store the probe output (will disable showing the output in console)<br>  -u                    Run in trusted mode<br>  -d <path></path>             Dump the instrumented classes to the specified path<br>  -pd <path></path>            The search path for the probe XML descriptors<br>  -classpath <path></path>     Specify where to find user class files and annotation processors<br>  -cp <path></path>            Specify where to find user class files and annotation processors<br>  -I <path></path>             Specify where to find include files<br>  -p <port>             Specify port to which the btrace agent listens for clients<br>  -statsd <host[:port]> Specify the statsd server, if any</host[:port]></port></file></btrace></btrace></pid></options></p>
</blockquote>
<p>根据上面的提示，btrace使用起来很简单，而且官方提供了一个简易的使用指南，在解压下载的压缩包中<code>E:/btrace-bin-1.3.9/docs</code>下有<code>usersguide.html</code>，用浏览器打开即可。BTrace支持四种方式的注解，分别是</p>
<ul>
<li><strong>Method Annotations</strong><ul>
<li>@com.sun.btrace.annotations.OnMethod</li>
<li>@com.sun.btrace.annotations.OnTimer</li>
<li>@com.sun.btrace.annotations.OnError</li>
<li>@com.sun.btrace.annotations.OnExit</li>
<li>@com.sun.btrace.annotations.OnEvent</li>
<li>@com.sun.btrace.annotations.OnLowMemory</li>
<li>@com.sun.btrace.annotations.OnProbe</li>
</ul>
</li>
<li><strong>Argument Annotations</strong><ul>
<li>@com.sun.btrace.annotations.Self</li>
<li>@com.sun.btrace.annotations.Return</li>
<li>@com.sun.btrace.annotations.CalledInstance</li>
<li>@com.sun.btrace.annotations.CalledMethod</li>
</ul>
</li>
<li><strong>Field Annotations</strong><ul>
<li>@com.sun.btrace.annotations.Export</li>
<li>@com.sun.btrace.annotations.Property</li>
<li>@com.sun.btrace.annotations.TLS</li>
</ul>
</li>
<li><strong>Class Annotations</strong><ul>
<li>@com.sun.btrace.annotations.DTrace</li>
<li>@com.sun.btrace.annotations.DTraceRef</li>
<li>@com.sun.btrace.annotations.BTrace</li>
</ul>
</li>
</ul>
<p>关于这些注解的具体解释可以去翻看docs目录下的用户指南，好了，废话不多说，下面简单操练起来。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>如果是在Maven项目中开发，那么首先需要引入BTrace的Jar包，由于Maven的中央仓库中只有1.x版本的BTrace，并没有高版本的，所以一般的做法是自己编译BTrace源码，将高版本的Jar发布到私服（Nexus）中，为简单起见，此处通过Maven指定依赖本地Jar即可，修改pom.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-agent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>E:/btrace-bin-1.3.9/build/btrace-agent.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>E:/btrace-bin-1.3.9/build/btrace-boot.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>E:/btrace-bin-1.3.9/build/btrace-client.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>首先编写想要追踪的示例，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceOnMethodDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">15</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"start main method..."</span>);</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再编写追踪代码示例，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.sun.btrace.annotations.BTrace;</div><div class="line"><span class="keyword">import</span> com.sun.btrace.annotations.OnMethod;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.println;</div><div class="line"></div><div class="line"><span class="meta">@BTrace</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tracer</span> </span>&#123;</div><div class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"java.lang.Thread"</span>, method = <span class="string">"start"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onThreadStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        println(<span class="string">"tracing method start"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意点</p>
<ul>
<li>Tracer类中的println方法并不是JDK中的方法，而是BTraceUtils中的静态方法</li>
<li>在追踪代码，原则上只能使用BTraceUtils中的静态方法，如果想要使用JDK中的方法，那么在命令行中需要使用<code>-cp</code>指定依赖的Jar</li>
<li>OnMethod这个注解只会在方法启动的时候被触发，如果该方法已经启动，再运行追踪代码是无法触发的，所以在示例中，先休息了15s钟</li>
</ul>
<p>运行BTraceOnMethodDemo，打开cmd，到Tracer类所在的目录下，运行</p>
<blockquote>
<p>D:/Demo/src/main/java&gt;jps<br>39808 Launcher<br>15480 RemoteMavenServer<br>40280 Jps<br>41880 AppMain<br>4764<br>D:/Demo/src/main/java&gt;btrace -v 41880 Tracer.java<br>DEBUG: assuming default port 2020<br>DEBUG: assuming default classpath ‘.’<br>DEBUG: compiling Tracer.java<br>DEBUG: compiled Tracer.java<br>DEBUG: attaching to 41880<br>DEBUG: checking port availability: 2020<br>DEBUG: attached to 41880<br>DEBUG: loading E:\btrace-bin-1.3.9\build\btrace-agent.jar<br>DEBUG: agent args: port=2020,statsd=,debug=true,bootClassPath=.,systemClassPath=<br>C:\Program Files\Java\jdk1.8.0_45\jre/../lib/tools.jar,probeDescPath=.<br>DEBUG: loaded E:\btrace-bin-1.3.9\build\btrace-agent.jar<br>DEBUG: registering shutdown hook<br>DEBUG: registering signal handler for SIGINT<br>DEBUG: submitting the BTrace program<br>DEBUG: opening socket to 2020<br>DEBUG: setting up client settings<br>DEBUG: sending instrument command<br>DEBUG: entering into command loop<br>DEBUG: received com.sun.btrace.comm.OkayCommand@396f6598<br>DEBUG: received com.sun.btrace.comm.RetransformationStartNotification@394e1a0f<br>DEBUG: received com.sun.btrace.comm.OkayCommand@27a5f880<br>DEBUG: received com.sun.btrace.comm.MessageCommand@53f65459<br>DEBUG: received com.sun.btrace.comm.MessageCommand@3b088d51<br>tracing method start</p>
</blockquote>
<p>注意要带上<code>-v</code>参数，否则控制台看不到任何输出，另外还可以利用<code>-o</code>参数将信息输出到指定的文件，运行BTraceOnMethodDemo，打开cmd，到Tracer类的目录下，运行</p>
<blockquote>
<p>D:/Demo/src/main/java&gt;jps<br>12064 Jps<br>24560 AppMain<br>41764 Launcher<br>15480 RemoteMavenServer<br>4764<br>D:/Demo/src/main/java&gt;btrace -o out.csv 24560 Tracer.java</p>
</blockquote>
<p>注意这时候out.csv文件时在Tracer.java所在目录的根目录下，也就是在<code>D:/Demo</code>下，在当前目录下是找不到的，是不是很变态。找到out.csv打开看看，就是追踪代码的输出内容</p>
<blockquote>
<p>BTrace Log: 17-9-20 下午3:16<br>tracing method start</p>
</blockquote>
<p>好了，整个流程就打通了，剩下的就是自己动手实战吧。此处仅给出一个简单示例，详情可以参看BTrace的用户指南，里面给出了更多详细的示例，只要打开动手一一实战即可。</p>
<p>BTrace虽然功能强大，但是并不完美，这是因为它有着诸多的限制，例如</p>
<ul>
<li>can <strong>not</strong> create new objects.</li>
<li>can <strong>not</strong> create new arrays.</li>
<li>can <strong>not</strong> throw exceptions.</li>
<li>can <strong>not</strong> catch exceptions.</li>
<li>can <strong>not</strong> make arbitrary instance or static method calls - only the <strong>public static</strong> methods of <strong><a href="javadoc/com/sun/btrace/BTraceUtils.html">com.sun.btrace.BTraceUtils</a></strong> class may be called from a BTrace program.</li>
<li>can <strong>not</strong> assign to static or instance fields of target program’s classes and objects. But, BTrace class can assign to it’s own static fields (“trace state” can be mutated).</li>
<li>can <strong>not</strong> have instance fields and methods. Only <strong>static public void</strong> returning methods are allowed for a BTrace class. And all fields have to be static.</li>
<li>can <strong>not</strong> have outer, inner, nested or local classes.</li>
<li>can <strong>not</strong> have synchronized blocks or synchronized methods.</li>
<li>can <strong>not</strong> have loops (<strong>for, while, do..while</strong>)</li>
<li>can <strong>not</strong> extend arbitrary class (super class has to be java.lang.Object)</li>
<li>can <strong>not</strong> implement interfaces.</li>
<li>can <strong>not</strong> contains assert statements.</li>
<li>can <strong>not</strong> use class literals.</li>
</ul>
<h4 id="BTrace命令详解"><a href="#BTrace命令详解" class="headerlink" title="BTrace命令详解"></a>BTrace命令详解</h4><ul>
<li><p><strong>btrace</strong><br>功能：用于运行BTrace跟踪程序。<br>命令格式：<br><code>btrace [-I &lt;include-path&gt;] [-p &lt;port&gt;] [-cp &lt;classpath&gt;] &lt;pid&gt; &lt;btrace-script&gt; [&lt;args&gt;]</code><br>示例：<br><code>btrace -cp build/  1200 AllCalls1.java</code><br>参数含义：<br>include-path指定头文件的路径，用于脚本预处理功能，可选；<br>port指定BTrace agent的服务端监听端口号，用来监听clients，默认为2020，可选；<br>classpath用来指定类加载路径，默认为当前路径，可选；<br>pid表示进程号，可通过jps命令获取；<br>btrace-script即为BTrace脚本；btrace脚本如果以.java结尾，会先编译再提交执行。可使用btracec命令对脚本进行预编译。<br>args是BTrace脚本可选参数，在脚本中可通过<code>$</code>和<code>$length</code>获取参数信息。</p>
</li>
<li><p><strong>btracec</strong><br>功能：用于预编译BTrace脚本，用于在编译时期验证脚本正确性。<br><code>btracec [-I &lt;include-path&gt;] [-cp &lt;classpath&gt;] [-d &lt;directory&gt;] &lt;one-or-more-BTrace-.java-files&gt;</code><br>参数意义同btrace命令一致，directory表示编译结果输出目录。</p>
</li>
<li><p><strong>btracer</strong><br>功能：btracer命令同时启动应用程序和BTrace脚本，即在应用程序启动过程中使用BTrace脚本。而btrace命令针对已运行程序执行BTrace脚本。<br>命令格式：<br><code>btracer &lt;pre-compiled-btrace.class&gt; &lt;application-main-class&gt; &lt;application-args&gt;</code><br>参数说明：<br>pre-compiled-btrace.class表示经过btracec编译后的BTrace脚本。<br>application-main-class表示应用程序代码；<br>application-args表示应用程序参数。<br>该命令的等价写法为：<br><code>java -javaagent:btrace-agent.jar=script=&lt;pre-compiled-btrace-script1&gt;[,&lt;pre-compiled-btrace-script1&gt;]* &lt;MainClass&gt; &lt;AppArguments&gt;</code></p>
</li>
</ul>
<p>BTrace基本就介绍完了，但是BTrace并不是完美的，比如当你想要追踪一个局部变量的，查看具体值的时候，却无能为力，不仅扼腕叹息，真是天妒英才啊，这么小的一个需求都无法cover？不用着急，后面就介绍一个更加强大的工具，Byteman。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在日常开发中，有一些常见的环境，比如Dev、UAT、预发、生产等，当然并不是每个公司都是这样。有时候开发环境一切正常，但是到线上的UAT环境
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="BTrace" scheme="http://www.codepub.cn/tags/BTrace/"/>
    
  </entry>
  
  <entry>
    <title>读《金字塔原理》</title>
    <link href="http://www.codepub.cn/2017/07/09/Read-the-minto-pyramid-principle/"/>
    <id>http://www.codepub.cn/2017/07/09/Read-the-minto-pyramid-principle/</id>
    <published>2017-07-09T10:20:40.000Z</published>
    <updated>2017-11-20T14:18:34.081Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作者简介：</strong>芭芭拉•明托，麦肯锡公司第一位女性咨询顾问。明托是哈佛商学院录取的第二批女学员之一，毕业时被国际知名管理咨询公司——麦肯锡聘请为该公司有史以来的第一位女性咨询顾问。她在写作方面的优势很快得到麦肯锡高层的赏识，负责提高麦肯锡公司员工的写作能力，致力于探索条理清晰的文章所必需的思维结构。本书在1973年首次出版，当即引起轰动，畅销欧美市场30年不衰，书中传授的方式与技巧，被公认为即便对于最有经验的管理者来说也是十分关键的。</p>
<h3 id="表达的逻辑"><a href="#表达的逻辑" class="headerlink" title="表达的逻辑"></a>表达的逻辑</h3><h4 id="为什么要用金字塔结构"><a href="#为什么要用金字塔结构" class="headerlink" title="为什么要用金字塔结构"></a>为什么要用金字塔结构</h4><p>文章中的思想必须符合以下规则：</p>
<ul>
<li>纵向：文章中任一层次上的思想必须是其下一层次思想的概括</li>
<li>横向：每组中的思想必须属于同一逻辑范畴</li>
<li>横向：每组中的思想必须按逻辑顺序组织</li>
</ul>
<p>组织思想基本上只可能有4种逻辑顺序：</p>
<ul>
<li>演绎顺序：大前提、小前提、结论</li>
<li>时间顺序：第一、第二、第三</li>
<li>结构顺序：波士顿、纽约、华盛顿</li>
<li>程度顺序：最重要、次重要、等等</li>
</ul>
<h4 id="金字塔内部的结构"><a href="#金字塔内部的结构" class="headerlink" title="金字塔内部的结构"></a>金字塔内部的结构</h4><p>利用金字塔中的子结构，能够加快你梳理思想的过程：</p>
<ul>
<li>主题与子主题之间的纵向关系</li>
<li>各子主题之间的横向关系</li>
<li>序言的叙述方式</li>
</ul>
<h4 id="如何构建金字塔"><a href="#如何构建金字塔" class="headerlink" title="如何构建金字塔"></a>如何构建金字塔</h4><p>自上而下法构建金字塔的步骤：</p>
<ul>
<li>提出主题思想</li>
<li>设想受众的主要疑问</li>
<li>写序言：背景-冲突-疑问-回答</li>
<li>与受众进行疑问/回答式对话</li>
<li>对受众的新疑问，重复进行疑问/回答式对话</li>
</ul>
<p>自下而上思考：</p>
<ul>
<li>列出你想表达的所有思想要点</li>
<li>找出各要点之间的逻辑关系</li>
<li>得出结论</li>
</ul>
<h4 id="序言的具体写法"><a href="#序言的具体写法" class="headerlink" title="序言的具体写法"></a>序言的具体写法</h4><p>文章的序言（前言、引言、导言）概括读者已知的信息，并将这些信息与文章将要回答的疑问建立联系，然后作者就可以将全部精力放在提供回答疑问的答案上。如果是写文章，就是“序言”；如果是演讲，就是“开场白”。</p>
<p>文章的序言必须用讲故事的形式，也就是说，序言必须先介绍读者熟悉的某些“背景”，说明发生的“冲突”，并由此引发读者的“疑问”，然后针对该“疑问”给出“答案”。这种讲故事的形式对于组织读者已知的信息非常有用。你一旦掌握了这种方法，就能够迅速构思出较短文章的结构。</p>
<p>之所以序言要用讲故事形式，是为了让读者抛开复杂的思想，专注于你的话题。激发读者兴趣，吸引注意力：新奇、悬念、与读者本人相关。</p>
<p>序言应当介绍4要素：</p>
<ul>
<li>介绍背景</li>
<li>指出冲突</li>
<li>引发疑问</li>
<li>给出答案</li>
</ul>
<h4 id="演绎推理与归纳推理"><a href="#演绎推理与归纳推理" class="headerlink" title="演绎推理与归纳推理"></a>演绎推理与归纳推理</h4><p>演绎是一种线性的推理方式，最终是为了得出一个由逻辑词“因此”引出的结论。归纳推理是将一组具有共同点的事实、思想或观点归类分组，并概括其共同性或论点。在演绎过程中，每个思想均由前一个思想导出；而在归纳过程中则不存在这种关系。</p>
<p>演绎推理非常繁琐，主要是因为演绎推理必须从简单明了的思想推导出复杂的思想，所以在写作过程中不要过多的使用演绎推理。而归纳与此相反，归纳法先说明如何做到，然后再详细阐述为什么，在实际情况中，归纳法往往效果更好，这是因为先说明行动，后说明原因，而读者往往最关心的就是那些行动。</p>
<p>如果把文章想象成金字塔的多层级结构，那么在较低的层次上使用演绎推理是可以的，但是在较高的层次上，归纳法总是比演绎法更容易理解，为什么这样讲？如果读者必须读完十几页，才能找到演绎推理的第一步和第二步之间的关系，又必须再读十几页才能找到第二步和第三步之间的关系，那么读者就无法快速理解这次演绎推理。</p>
<p>如果准备在金字塔结构的较低层次上使用演绎推理，需要注意如下两点</p>
<ul>
<li>演绎推理的过程不要超过4个步骤</li>
<li>推导出的结论不要超过两个</li>
</ul>
<p>演绎推理需要完成3个步骤</p>
<ul>
<li>阐述世界上已存在的某种情况</li>
<li>阐述世界上同时存在的相关情况。如果第二个表述是针对第一个表述的主语或谓语的，则说明这两个表述相关</li>
<li>说明这两种情况同时存在时隐含的意义</li>
</ul>
<p>演绎推理与归纳推理的区别</p>
<ul>
<li>演绎推理，第二点是对第一点主语或谓语的论述</li>
<li>归纳推理，同组中的思想具有类似的主语或谓语</li>
</ul>
<h3 id="思考的逻辑"><a href="#思考的逻辑" class="headerlink" title="思考的逻辑"></a>思考的逻辑</h3><h4 id="应用逻辑顺序"><a href="#应用逻辑顺序" class="headerlink" title="应用逻辑顺序"></a>应用逻辑顺序</h4><p>所有列入同一组中的思想必须具有某种逻辑顺序，这条规则可以保证你列入同一组中的思想确实属于这一组，还可以防止你遗漏任何相关的思想。常用的顺序主要有三种：时间顺序、结构顺序、程度顺序。</p>
<h4 id="概括各组思想"><a href="#概括各组思想" class="headerlink" title="概括各组思想"></a>概括各组思想</h4><p>思想的表达方式可以是行动性语句，即告诉读者做什么事；也可以是描述性语句，即告诉读者关于某些事的情况。</p>
<ul>
<li>概括行动性思想（介绍采取的行动、行为、步骤、流程）时，应说明采取行动后取得的“结果”（效果、达到的目标）</li>
<li>概括描述性思想（介绍背景、信息）时，应说明这些思想具有的“共同点的含义”（共同点的意义）</li>
</ul>
<h3 id="解决问题的逻辑"><a href="#解决问题的逻辑" class="headerlink" title="解决问题的逻辑"></a>解决问题的逻辑</h3><h4 id="界定问题"><a href="#界定问题" class="headerlink" title="界定问题"></a>界定问题</h4><p>判断问题是否存在，通常要看经过努力得到的结果与希望得到的结果之间是否有差距。由某一特定背景导致的某一特定结果，称为非预期结果（R1，Undesired Result）。“问题”是指你不喜欢某一结果，想得到其他结果，称为期望结果（R2，Desired Result）。解决方案则是指如何从现状R1到目标R2。</p>
<h4 id="结构化分析问题"><a href="#结构化分析问题" class="headerlink" title="结构化分析问题"></a>结构化分析问题</h4><p>分析问题的标准流程是：收集信息-&gt;描述发现-&gt;得出结论-&gt;提出方案。经过一系列有意识、有条理地去收集事实，得出符合逻辑的发现。但是多数人都是收集该领域一切可以收集到的资料，等所有事实和资料齐备时才正式开始分析。这种做法可行，但是需要付出额外的辛苦，比较好的方法是建立诊断框架和逻辑树指导，来分析和引导思维，不仅能提高解决问题的效率，而且简化了把结果构建成金字塔的工作。</p>
<p>结构化分析问题的方法主要是</p>
<ul>
<li>从信息资料入手</li>
<li>设计诊断框架</li>
<li>使用诊断框架</li>
<li>建立逻辑树</li>
<li>是非问题分析</li>
</ul>
<h3 id="演示的逻辑"><a href="#演示的逻辑" class="headerlink" title="演示的逻辑"></a>演示的逻辑</h3><p>在纸面上或屏幕上展示你的思想时，无论采用何种形式，在视觉上，你都需要确保能加强组成金字塔的思想之间的逻辑性和它们之间的相互关系。读者或观众总是先看到逻辑关系的存在，然后才能理解它。因此你要用读者眼睛所看到的来强化她们的头脑所接收的。</p>
<h4 id="在书面上呈现金字塔"><a href="#在书面上呈现金字塔" class="headerlink" title="在书面上呈现金字塔"></a>在书面上呈现金字塔</h4><p>一般来说，文章较短，读者很容易明白文中的要点及其相互之间的关系。而对于长文，要突出显示文章的框架结构，在页面上呈现出金字塔层级，常见的方法很多，如下所示：</p>
<ul>
<li>多级标题法</li>
<li>下划线法</li>
<li>数字编号法</li>
<li>行首缩进法</li>
<li>项目符号法</li>
</ul>
<p>另一个注意点是文章的上下文之间要有过渡，在写完序言后，进入文章正文，需要一段简短的文字，在每组主要思想观点开始或结束的地方稍作铺垫，让读者知道已经论述的和下一步计划论述的内容，同时保证论点和论点之间的连接流畅且不机械。</p>
<h4 id="在PPT演示文稿中呈现金字塔"><a href="#在PPT演示文稿中呈现金字塔" class="headerlink" title="在PPT演示文稿中呈现金字塔"></a>在PPT演示文稿中呈现金字塔</h4><p>设计PPT演示文稿的最基本原则</p>
<ul>
<li>文字幻灯片应只包含最重要的、经过适当分组和总结的思想，叙述时应尽量简洁</li>
<li>演示文稿应图文并茂，使用各种图表相配合</li>
<li>演示文稿应呈现经过深思熟虑后的故事梗概和剧本</li>
<li>演示文稿中，理想的图表比例占90%，文字占10%</li>
</ul>
<p>制作现场演示用的文字幻灯片时，需要强调的是，只有你，演示者，才是表演的明星。房间里所有听众最感兴趣的不是幻灯片，而是你。幻灯片只不过是视觉上的辅助手段，其作用主要是让演示更加生动。</p>
<p>决定一张幻灯片的内容，应牢记以下指导性原则</p>
<ul>
<li>每次只演示和说明一个论点</li>
<li>论点应使用完整的陈述句，而不是标题性语言</li>
<li>文字应尽量简短</li>
<li>使用简单的词汇和数字</li>
<li>字号应足够大</li>
<li>注意幻灯片的趣味性</li>
<li>用逐级展开呈现，提高趣味性</li>
</ul>
<h4 id="在字里行间呈现金字塔"><a href="#在字里行间呈现金字塔" class="headerlink" title="在字里行间呈现金字塔"></a>在字里行间呈现金字塔</h4><p>在理解每个字词的时候，你的头脑中应该逐步描绘出一幅思想图画。当你理解一个又一个的短语和句子时，图画的细节变得更加丰富。你所描绘的图像不是摄影意义上的图像，而是作者所说的“记忆图像”，随着文章的进展而逐渐清晰起来。有关记忆的研究已经证明图像能帮助增加记忆，但同时也表明，忘记和添加哪些细节取决于人们的感情偏好。尽管如此，记忆图像确实能在阅读过程中，帮助你逐字逐句记忆段落和从中提取信息。</p>
<p>以图像形式存储知识非常重要，因为阅读是一个逐字逐句进行的过程，而且我们的头脑只能容纳有限的词汇。通过从文字恢复图像的方法，读者不仅能大量传递知识，使头脑更加有效地处理，而且能用清晰的图像传递信息，便于回忆。</p>
<p>引用威廉·明托教授的一段话来阐释作者与读者或者说听众的关系</p>
<blockquote>
<p>写作时，你好像一位司令官，指挥着千军万马，排队通过一个每次只能通过一个人的狭隘关口；而你的读者则在另一边迎接，将部队进行重新编排和组织。无论主题多么大或者多么复杂，你只能以这种方式表达。</p>
<p>最终你会发现，这就是我们在顺序和编排上对读者应尽的义务，以及为什么修辞学者们除了强调修辞得体和别出心裁外，还把顺序和编排当作对那些给予自己厚爱的人的应尽职责。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;芭芭拉•明托，麦肯锡公司第一位女性咨询顾问。明托是哈佛商学院录取的第二批女学员之一，毕业时被国际知名管理咨询公司——麦肯锡聘请为该公司有史以来的第一位女性咨询顾问。她在写作方面的优势很快得到麦肯锡高层的赏识，负责提高麦肯锡公司员工
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>用RAMDirectory做缓存提高Lucene性能</title>
    <link href="http://www.codepub.cn/2017/06/28/Use-RAMDirectory-to-do-the-cache-to-improve-lucene-s-performance/"/>
    <id>http://www.codepub.cn/2017/06/28/Use-RAMDirectory-to-do-the-cache-to-improve-lucene-s-performance/</id>
    <published>2017-06-28T14:02:21.000Z</published>
    <updated>2017-11-20T14:18:34.041Z</updated>
    
    <content type="html"><![CDATA[<p>RAMDirectory和FSDirectory都继承自BaseDirectory，而BaseDirectory继承自Directory，Directory是Lucene中设计的一个顶层抽象类，可以将其看做本地文件系统的一个目录。</p>
<p>RAMDirectory是基于内存实现的，具有较高的存储速度，但是受到内存大小的限制，而FSDirectory是基于文件系统实现的，针对不同的操作系统有不同的具体实现类，这些实现类无需用户操心，只需要调用FSDirectory.open(Path path)方法，它就会帮助我们选择最适合的子类，FSDirectory的瓶颈在于磁盘I/O。</p>
<p>如果机器内存足够大的话，那么组合使用RAMDirectory和FSDirectory将能够极大地提高Lucene的性能。组合使用两者的应用场景很多，不同的场景可以分别解决不同的需求，仅列举如下</p>
<ul>
<li>批量索引，而无需检索的情况下，先把document存到RAMDirectory中，当达到一定数量之后，再把这些索引一次性加入FSDirectory里</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.WhitespaceAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.StringField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.MatchAllDocsQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/06/19 15:31.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: 基于Lucene 6.5开发</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RamFSDirectoryDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        IndexWriter ramWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer()).setOpenMode(IndexWriterConfig.OpenMode.CREATE));</div><div class="line"></div><div class="line">        FSDirectory fsDirectory = FSDirectory.open(Paths.get(<span class="string">"F:/index_RAM_FS"</span>));</div><div class="line">        IndexWriter fsWriter = <span class="keyword">new</span> IndexWriter(fsDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer()).setOpenMode(IndexWriterConfig.OpenMode</div><div class="line">                .CREATE_OR_APPEND));</div><div class="line"></div><div class="line">        <span class="comment">//简单起见，这里的数量都比较少，例如索引10000个document，每100个document作为一批</span></div><div class="line">        <span class="keyword">int</span> tempCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            Document document = <span class="keyword">new</span> Document();</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"key"</span>, String.valueOf(i), Field.Store.YES));</div><div class="line">            ramWriter.addDocument(document);</div><div class="line">            tempCount++;</div><div class="line">            <span class="keyword">if</span> (tempCount % <span class="number">100</span> == <span class="number">0</span>) &#123;</div><div class="line">                ramWriter.commit();</div><div class="line">                ramWriter.close();</div><div class="line">                fsWriter.addIndexes(ramDirectory);</div><div class="line">                ramDirectory.close();</div><div class="line">                fsWriter.commit();</div><div class="line">                ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">                ramWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer()).setOpenMode(IndexWriterConfig.OpenMode.CREATE));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//退出时确保RAMDirectory中内容都被加入本地</span></div><div class="line">        <span class="keyword">if</span> (ramWriter != <span class="keyword">null</span>) &#123;</div><div class="line">            ramWriter.commit();</div><div class="line">            ramWriter.close();</div><div class="line">            fsWriter.addIndexes(ramDirectory);</div><div class="line">            ramDirectory.close();</div><div class="line">        &#125;</div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(fsWriter.getDirectory()));</div><div class="line">        fsWriter.close();</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        System.out.println(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>索引的同时需要搜索，前提是内存总量大于索引文件总量，如果要求新加入的索引对搜索可见，即实时搜索，要怎么做呢？显然实时搜索需要writer和searcher共用同一份索引，同时要定时的将内存中索引备份到文件系统，否则机器一旦宕机，内存中所有的索引文件都将丢失。代码实现也很简单，在备份的时候，可以使用调度线程去进行备份操作，同时还不影响主线程继续接受索引请求；备份策略有两种：全量和增量，增量直接比较文件名，将新增文件拷贝到文件系统，同时删除已过时的索引文件即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.WhitespaceAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.StringField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.MatchAllDocsQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.Directory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.IOContext;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Path;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/06/19 15:31.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: 基于Lucene 6.5开发</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RamFSDirectoryDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IndexWriter ramWriter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RAMDirectory ramDirectory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Backup backup = <span class="keyword">new</span> Backup();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">//将文件系统中索引文件加载到内存中</span></div><div class="line">        FSDirectory fsDirectory = FSDirectory.open(Paths.get(<span class="string">"F:/index_RAM_FS"</span>));</div><div class="line">        ramDirectory = <span class="keyword">new</span> RAMDirectory(fsDirectory, IOContext.READONCE);</div><div class="line">        fsDirectory.close();</div><div class="line"></div><div class="line">        IndexWriterConfig indexWriterConfig = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> WhitespaceAnalyzer());</div><div class="line">        indexWriterConfig.setIndexDeletionPolicy(<span class="keyword">new</span> SnapshotDeletionPolicy(<span class="keyword">new</span> KeepOnlyLastCommitDeletionPolicy()));</div><div class="line">        ramWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, indexWriterConfig);</div><div class="line"></div><div class="line">        <span class="comment">//先添加一条记录</span></div><div class="line">        Document document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"first"</span>, <span class="string">"first"</span>, Field.Store.YES));</div><div class="line">        ramWriter.addDocument(document);</div><div class="line">        ramWriter.commit();</div><div class="line"></div><div class="line">        <span class="comment">//定时备份线程</span></div><div class="line">        ScheduledExecutorService backupThread = Executors.newSingleThreadScheduledExecutor();</div><div class="line">        backupThread.scheduleAtFixedRate(backup, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">        <span class="comment">//可以继续接受索引请求</span></div><div class="line">        document = <span class="keyword">new</span> Document();</div><div class="line">        document.add(<span class="keyword">new</span> StringField(<span class="string">"key"</span>, <span class="string">"key"</span>, Field.Store.YES));</div><div class="line">        ramWriter.addDocument(document);</div><div class="line">        ramWriter.commit();</div><div class="line"></div><div class="line">        <span class="comment">//等待索引拷贝完成</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//接受搜索请求，可实现实时搜索</span></div><div class="line">        IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramWriter.getDirectory()));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(<span class="keyword">new</span> MatchAllDocsQuery());</div><div class="line">        System.out.println(<span class="string">"total hits: "</span> + count);</div><div class="line">        System.out.println(<span class="string">"内存中索引文件："</span> + Arrays.asList(ramDirectory.listAll()));</div><div class="line">        <span class="comment">//查看备份索引是否完整，此处有一个注意点，如果需要在备份索引上打开searcher，那么在备份索引文件的时候需要先备份其它文件，最后再备份segments_N文件</span></div><div class="line">        <span class="comment">//因为开searcher的时候，会先加载segments_N文件，这种方式可以保证加载完segments_N文件之后，再加载其它文件一定成功</span></div><div class="line"></div><div class="line">        fsDirectory = FSDirectory.open(Paths.get(<span class="string">"F:/index_RAM_FS"</span>));</div><div class="line">        System.out.println(<span class="string">"备份中索引文件："</span> + Arrays.asList(fsDirectory.listAll()));</div><div class="line">        backupThread.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Backup</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            IndexWriterConfig config;</div><div class="line">            SnapshotDeletionPolicy indexDeletionPolicy = <span class="keyword">null</span>;</div><div class="line">            IndexCommit snapshot = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ramWriter.commit();</div><div class="line">                config = (IndexWriterConfig) ramWriter.getConfig();</div><div class="line">                indexDeletionPolicy = (SnapshotDeletionPolicy) config.getIndexDeletionPolicy();</div><div class="line">                snapshot = indexDeletionPolicy.snapshot();</div><div class="line">                config.setIndexCommit(snapshot);</div><div class="line">                Collection&lt;String&gt; fileNames = snapshot.getFileNames();</div><div class="line">                Path path = Paths.get(<span class="string">"F:/index_RAM_FS"</span>);</div><div class="line">                <span class="comment">//全量增量任选一种即可</span></div><div class="line">                <span class="keyword">boolean</span> b = incrementalBackup(fileNames, path);</div><div class="line">                <span class="comment">//boolean b = fullBackup(fileNames, path);</span></div><div class="line">                <span class="keyword">if</span> (!b) &#123;</div><div class="line">                    System.err.println(<span class="string">"Backup occurs error!"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                System.err.println(e.getMessage());</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    indexDeletionPolicy.release(snapshot);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                    System.err.println(e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fullBackup</span><span class="params">(Collection&lt;String&gt; fileNames, Path path)</span> </span>&#123;</div><div class="line">            Objects.requireNonNull(path);</div><div class="line">            Directory to;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                to = FSDirectory.open(path);</div><div class="line">                <span class="comment">// 全量备份，直接清空拷贝</span></div><div class="line">                <span class="keyword">for</span> (File file : path.toFile().listFiles()) &#123;</div><div class="line">                    file.delete();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (String fileName : fileNames) &#123;</div><div class="line">                    to.copyFrom(ramDirectory, fileName, fileName, IOContext.DEFAULT);</div><div class="line">                &#125;</div><div class="line">                to.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">incrementalBackup</span><span class="params">(Collection&lt;String&gt; fileNames, Path path)</span> </span>&#123;</div><div class="line">            <span class="comment">// 增量备份，稍微复杂一些，比较文件名，将ramDirectory中新增索引拷贝过去，同时将ramDirectory中不存在的索引但是在path中存在的旧索引删除</span></div><div class="line">            Objects.requireNonNull(path);</div><div class="line">            <span class="comment">//fileNames被IndexCommit引用，需要重新构造set集合，进行移除操作</span></div><div class="line">            Set&lt;String&gt; files = <span class="keyword">new</span> HashSet&lt;&gt;(fileNames);</div><div class="line">            <span class="keyword">for</span> (File file : path.toFile().listFiles()) &#123;</div><div class="line">                <span class="keyword">if</span> (files.contains(file.getName())) &#123;</div><div class="line">                    <span class="comment">//该索引已存在，则不拷贝</span></div><div class="line">                    files.remove(file.getName());</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//删除已经过时的索引</span></div><div class="line">                    file.delete();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//拷贝全部新增索引</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Directory to = FSDirectory.open(path);</div><div class="line">                <span class="keyword">for</span> (String file : files) &#123;</div><div class="line">                    to.copyFrom(ramDirectory, file, file, IOContext.DEFAULT);</div><div class="line">                &#125;</div><div class="line">                to.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果内存不够大，不能够存放全部的本地文件系统索引，那么如何实现呢？这时候，需要两套IndexWriter，一套用来处理本地文件系统中的索引，另一套在内存中可以接受新的索引请求；对索引的操作无非就是新增、删除、更新这三种，下面分别论述</p>
<ul>
<li>删除索引： 对于删除操作比较简单，两个IndexWriter都执行一次即可，如果其中一个IndexWriter中不存在待删除的索引的话，那么对索引文件不会有任何影响；这时候又分两种情况，一是待删除的索引在内存中，那么删除-提交-重新打开索引，耗时很短；二是待删除索引在硬盘上，这时候删除-提交，到底要不要重新打开，需要视业务而定，因为硬盘上的索引通常是很大的，如果频繁删除频繁重新打开的话，是很耗性能的，而如果不重新打开，这时候删除的索引对searcher是不可见的，也就是说用户仍然可以搜索到已删除的索引，比较好的方式是用一个后台线程去定时的重新打开硬盘索引，然后更新searcher即可，但是这样对于删除操作无法做到准实时，会有一定的延时。</li>
<li>新增索引：所有的新增操作都使用内存中的IndexWriter（称为A），然后提交-重新打开索引-更新searcher，一切都是在内存中操作，耗时极短，对于实时搜索是解决了，而且Lucene中已经提供了MultiReader可以组合多个子reader，很适合这种情况；但是当内存中索引尺寸达到一定大小之后，需要将其合并到文件系统中；在合并的时候还需要另外再开一个内存中的IndexWriter（称为B）用来接受索引合并期间的索引新增操作。不过这种方式实现起来很复杂，需要处理很多问题，例如在内存索引 A 和硬盘索引合并期间如果有更新删除操作怎么处理？在合并之后需要更新MultiReader，但是旧的MultiReader上面还挂有搜索请求怎么办？在新开一个内存索引 B 之后，如何让MultiReader覆盖住它？因为在 B 中必须先有索引，然后才能开Reader，进而才能更新MultiReader；若新增索引速度实在太快，在合并过程没有完成的时候，内存索引又满了，要怎么办？除此以外还有很多问题需要考虑。</li>
<li>更新索引：更新其实可以看作是两步操作，先删除后新增，这两步可以借鉴上面的论述。更新操作是无法同时应用于两个IndexWriter的，因为在Lucene中更新的逻辑是这样的，如果存在则更新，如果不存在则新增，那么假设一个IndexWriter中存在，另一个不存在，如果两个都应用更新，那么最后的结果很简单就是存在两份一样的document了。</li>
</ul>
</li>
</ul>
<p>个人理解优雅的程序应该是简单的，越是简单的程序其实越是健壮，这种方案实现起来很复杂，即使这么复杂的程序实现了，其健壮性仍然值得担忧，所以不是特别推荐使用这种方案。比较好的方案当然是上Elasticsearch集群了，Elasticsearch的刷新时间默认是1s钟，也就是说，最迟1s之后，就可以看到新的数据。当然如果非要针对Lucene进行开发，可以参考<a href="http://www.cnblogs.com/forfuture1978/archive/2010/11/29/1891476.html" target="_blank" rel="external">Linked公司开源的Zoie搜索引擎</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAMDirectory和FSDirectory都继承自BaseDirectory，而BaseDirectory继承自Directory，Directory是Lucene中设计的一个顶层抽象类，可以将其看做本地文件系统的一个目录。&lt;/p&gt;
&lt;p&gt;RAMDirectory是基
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>Maven引入本地依赖Jar到可执行Jar包中</title>
    <link href="http://www.codepub.cn/2017/06/13/Maven-introduces-local-dependency-jar-to-executable-jar-packages/"/>
    <id>http://www.codepub.cn/2017/06/13/Maven-introduces-local-dependency-jar-to-executable-jar-packages/</id>
    <published>2017-06-13T14:17:24.000Z</published>
    <updated>2017-11-20T14:18:34.160Z</updated>
    
    <content type="html"><![CDATA[<p>在Maven中，默认地，是不会将依赖的Jar包打入可执行Jar包的，如果需要将依赖打入可执行Jar包，需要在<code>pom</code>中添加<code>maven-assembly-plugin</code>插件，这个很容易实现，但是在正规开发中不推荐这样使用，为什么？因为稍微大型一些的项目都至少有几十个依赖项，而每次打包都将这些Jar包打入可执行Jar，使得最后生成的可执行Jar体积非常大。标准的做法是，将所有的依赖Jar包都打入lib目录中，而在可执行Jar的<code>MANIFEST.MF</code>中指定lib路径即可。这也很容易实现，并不是本文的重点，本文的重点是如何将不在Maven中央仓库中的Jar包，或者说依赖本地的Jar包打入可执行Jar，并更新<code>MANIFEST.MF</code>文件。</p>
<p>例如在我的Maven项目中，需要依赖本地Jar，首先将依赖的Jar复制到<code>src/main/resources/lib</code>目录下，引用如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yuewen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHORT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/lib/lucene-1.0.0-SNAPSHORT.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里的scope只能是system范围，systemPath属性指定Jar包的路径。</p>
<p>下一步将所有依赖的Jar包打入lib目录中，方式如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--将依赖的资源全部打入lib目录--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">excludeTransitive</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeTransitive</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">stripVersion</span>&gt;</span>false<span class="tag">&lt;/<span class="name">stripVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">excludeTransitive</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeTransitive</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">stripVersion</span>&gt;</span>false<span class="tag">&lt;/<span class="name">stripVersion</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>至此，你在Maven项目中，依赖的所有Jar都被打入到<code>target/lib</code>目录下了，剩下的关键一步就是如何添加<code>MANIFEST.MF</code>文件了。在pom中添加如下插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--打包插件，在Jar包中添加Class-Path和Main-Class--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--使用自己的Manifest文件，运行正常--&gt;</span></div><div class="line">            <span class="comment">&lt;!--&lt;manifestFile&gt;src/main/resources/META-INF/MANIFEST.MF&lt;/manifestFile&gt;--&gt;</span></div><div class="line">            <span class="comment">&lt;!--使用插件添加的Manifest文件，运行正常，一定要注意Manifest中jar包名称和lib文件夹下jar包名称版本号后缀等一定要一致，否则找不到依赖jar，此处有坑--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!--指定依赖资源路径前缀--&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>cn.codepub.maven.test.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--可以把依赖本地系统的Jar包加入Manifest文件中--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>lib/lucene-1.0.0-SNAPSHORT.jar<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<p>运行<code>mvn clean package</code>执行打包，完成之后，将包含依赖资源的lib目录和可执行Jar放在同一级目录下即可，这样在运行<code>java -jar xxx.jar</code>的时候，可执行Jar包可以准确地找到依赖Jar包。并且以这种方式打出来的可执行Jar体积非常小，一般都是几百KB而已。完整的<code>MANIFEST.MF</code>文件如下所示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Built-By: wangxu</div><div class="line">Class-Path: lib/lombok-1.16.12.jar lib/guava-20.0.jar lib/log4j-api-2.</div><div class="line"> 7.jar lib/log4j-core-2.7.jar lib/lucene-1.0.0-SNAPSHORT.jar</div><div class="line">Created-By: Apache Maven 3.3.3</div><div class="line">Build-Jdk: 1.8.0_45</div><div class="line">Main-Class: cn.codepub.maven.test.Main</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Maven中，默认地，是不会将依赖的Jar包打入可执行Jar包的，如果需要将依赖打入可执行Jar包，需要在&lt;code&gt;pom&lt;/code&gt;中添加&lt;code&gt;maven-assembly-plugin&lt;/code&gt;插件，这个很容易实现，但是在正规开发中不推荐这样使用，为什么
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Maven" scheme="http://www.codepub.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>读《未来简史》</title>
    <link href="http://www.codepub.cn/2017/06/11/Read-a-brief-history-of-tomorrow/"/>
    <id>http://www.codepub.cn/2017/06/11/Read-a-brief-history-of-tomorrow/</id>
    <published>2017-06-11T14:35:34.000Z</published>
    <updated>2017-11-20T14:18:34.051Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作者简介：</strong>尤瓦尔•赫拉利，1976年生，青年怪才，全球瞩目的新锐历史学家，牛津大学历史学博士，耶路撒冷希伯来大学历史系教授，著有国际畅销书《人类简史》。其新作《未来简史》，以宏大视角审视人类未来的终极命运，甫一出版就在全球掀起一股风潮，引起广泛关注。</p>
<h4 id="人类的新议题"><a href="#人类的新议题" class="headerlink" title="人类的新议题"></a>人类的新议题</h4><p>在这一章中，作者提出在21世纪，人类面临的三大议题似乎是不死、快乐和神性。现今因肥胖而死亡的人数已经远超因饥饿而死亡的人数了；同样因自杀而死亡的人数也已经远超因战争和恐怖主义而死亡的人数了，以目前的科技向前推进，在可以想象的未来，也许不死或者说永生可以成为一部分富人可选的一种生活方式呢。至于快乐不仅仅是物质上的，当然也包括精神上的，在这本书中，作者似乎特别喜欢谈动物，比如说松鼠储藏各类坚果不就是为了满足内心的快乐吗？这和人类储藏房产、纸币等等不是异曲同工吗？其实所谓的欲壑难填是有缘由的，在得到快感时，我们的反应不是满足，反而是想得到更多。这就不断的促使我们去持续地追求能够给我们带来快感的东西。在追求幸福和不死的过程中，人类事实上是试着把自己提升到神的地位。这时候的神不仅仅是宗教崇拜中那高高在上的神了，当人类自己能够实现永生并且可以获取无穷无尽的快乐，那么他们的心中估计已经把自己看作是地球的神了，那个时候，也许宗教就自然而然消逝了。</p>
<h4 id="人类世"><a href="#人类世" class="headerlink" title="人类世"></a>人类世</h4><p>为什么叫人类世，很奇怪的一个名字，科学家将地球的历史分为不同的“世”，例如更新世、上新世和中新世。过去的七万年称为“人类世”，也就是人类的时代。原因在于这几万年来，人类已经成为全球生态变化唯一最重要的因素。现在拜人类所赐，全球大型动物（体重不只是几公斤）有超过90%不是人类就是家畜。全球大型动物数量中，人类约有3亿吨，野生大型动物约有1亿吨，家畜约有7亿吨。好莱坞大片中经常会以外星人入侵啦、或者行星撞击地球啦为噱头，其实完全不必担心，这样的风险小之又小。与其害怕小行星，还不如害怕人类自己。在过去不过短短一世纪，人类造成的影响可能已经超过6500万年前那颗灭绝恐龙的小行星。</p>
<p>应该说，对地球上除了人类来说的所有其他物种来说，人类是最危险的杀手。在智人全球迁徙的过程中，他们灭掉了所有其他人类物种（现在的人类主要是智人，当年除了智人，还有很多人种）、澳大利亚90%的大型动物、美国75%的大型哺乳动物、全球大约50%的大型陆上哺乳动物；而且此时他们甚至还没开始种小麦，还没开始制作金属工具、还没开始写下任何文字，也还没铸出任何钱币。</p>
<h4 id="人类的特殊之处"><a href="#人类的特殊之处" class="headerlink" title="人类的特殊之处"></a>人类的特殊之处</h4><p>这一章非常有趣，按理说啊，人类主宰世间万物，那么人类必然有优越于其他所有物种的地方，大多数人都坚信，人类拥有灵魂和心灵，而其他劣等动物并不具备这两者，这在科学上被证明了是胡诌，因为科学家无论怎样实验都无法证明人类拥有灵魂。而心灵和灵魂大不相同，心灵是脑中主观体验的流动。这些心理上的体验，就是各种紧密相连的感觉、情感和思想，忽闪忽现、立刻消失，接着其他体验又倏然浮现与消散，于电光火石间来了又去。把这种种体验集合起来，就构成了意识流。灵魂有人信有人不信，但就意识流来说，几乎所有人都相信。但是在这一点上，所有动物并不输于人类，所有哺乳动物和鸟类以及至少某些爬行动物和鱼类，都具有感觉和情感。就这两点来说，人类和其他各种动物其实是平等的。</p>
<p>关于意识这个东西，不仅人类无法自证，而且无法他证，什么意思？假设人工智能不断发展，有一天人工智能说自己有意识，我们应该相信吗？早在几千年前，哲学家就已经发现，没有办法明确证明除了自己以外的任何事物具有意识。根据目前的科学定论，我所体验到的一切都是脑活动的结果，所以理论上确实能够模拟出一个我完全无法与“真实”世界分辨的虚拟世界。这不就是各种脑洞大开的电影里所展现的吗，甚至我们其实已经是活在营养液中而不自知呢，我们所感受到的驱壳等等一切行为感受，都是那个泡在营养液的大脑里的神经元之间不断流动的电子所致呢？所有的生老病死等等其实都是人工智能虚拟出来的结果呢？</p>
<p>在这里作者点出，人类真正胜出的地方在于大规模且灵活的合作，这种合作与蜂群和象群、黑猩猩有所不同，蜜蜂虽然也能进行大规模的合作，但是它们缺乏灵活性，比如无论有多么严重的压迫与剥削，它们从不会把自己的蜂后送上断头台，进而建立共和国；而象群与猩猩很难进行陌生者之间的合作，它们的合作多是基于血缘关系或者是熟知关系，两只不认识的大象，别说进行合作，单是一只大象融入另一个陌生的象群都是难上加难，而只有智人才能进行这种大规模的无数陌生个体之间进行的合作。正是这种实际具体的能力，决定了为何目前主宰地球的是人类，而不是什么永恒的灵魂或是独有的意识。</p>
<p>关于革命的精髓也是合作，以俄国爆发的十月革命为例，当时俄国中上阶层人数至少有300万人，但共产主义者仅有23000名，然而就是这么一小撮人建立的强大的苏维埃政权。在十月革命之前，俄国有1.8亿农民和工人，仅有300万俄国贵族、官员等，但是这些精英却知道如何合作守卫其共同利益，但那1.8亿平民却无法有效动员，直到23000名共产主义者的出现。想掀起一场革命，只靠人数绝对远远不够。</p>
<p>智人统治世界，是因为只有智人能编织出互为主体的意义之网：其中的法律、约束力、实体和地点都只存在于他们共同的想象之中。这张网，让所有动物中只有人类能组织十字军、革命和人权运动。除此以外，另一个特殊之处是在所有动物中只有人类能够想象虚幻的东西的存在，例如猎豹埋伏着等待捕获猎物，但是它仅能想象这个世界上真实存在的东西例如羚羊，却无法想象不存在的东西，例如美元、谷歌或欧盟，如果它知道美元能买到大把的羚羊，也许它就不会费那么大力气去亲自捕猎了。到了21世纪，虚构想象有可能成为世界上最强大的力量，甚至超越自然选择。因此，如果我们想了解人类的未来，只是破译基因组、处理各种数据数字还远远不够，我们还必须破解种种赋予世界意义的虚构想象。</p>
<h4 id="说书人"><a href="#说书人" class="headerlink" title="说书人"></a>说书人</h4><p>所有的现存世界，其立身之本都是依赖于人类虚构出来的各种概念，而且这就像既得利益阶层一样，每一个依靠这种虚构概念上位的人最后都会挺身而出继续维护这种虚构的权威性。虚构有其存在的必要性，正是所有人都在同一个虚构故事的体系之内，智人才能进行更加复杂的合作，因为所有人共同认同的价值体系，为内部的融合以及建立组织提供了先决条件，而动物世界就算是最大的族群也达不到人类组织一场现代化战争的规模，或者说，即便动物世界存在这样的族群，那么其必然无法进行有效的组织，结果就是乱作一团，每只动物都可以自作主张，毫无秩序可言。</p>
<p>在21世纪，我们还会创造出比以往更强大的虚构概念以及更极权的宗教。在生物科技和计算机算法的帮助下，这些宗教不但会控制我们每分每秒的存在，甚至将塑造我们的身体、大脑和心智，创造出完整的虚拟世界。真要如此，在区分虚构与真实、宗教与科学将会变得更加困难，但又比以往更加重要。也许在不久的世纪里，人工智能统治世界，而人类的大脑仅仅存在于人工智能所为其构建的完美的虚拟世界之中。</p>
<h4 id="一对冤家"><a href="#一对冤家" class="headerlink" title="一对冤家"></a>一对冤家</h4><p>这里说的一对冤家指的是科学与宗教。在人类的发展进程中，科学与宗教有合作有冲突；科学与宗教追求的都是真理，只是有时候它们追求的是各自推崇且不同的真理。但另外一些时候，科学或宗教都不那么在乎真理，因此二者十分容易妥协、共存甚至合作。宗教最在乎的是秩序，宗教的目的就是创造和维持社会结构；而科学最在乎的则是力量，科学的目的是通过研究得到力量。</p>
<h4 id="与“现代”的契约"><a href="#与“现代”的契约" class="headerlink" title="与“现代”的契约"></a>与“现代”的契约</h4><p>如今，经济增长在全球已经取得了宗教般的地位，不管一个国家或地区存在什么样的问题，所有的当权者或者领导人都寄希望于经济增长，认为只要经济增长就能解决潜在的问题，包括贫困、落后、纷争、混乱等。所有的领导人都把经济的发展成果看成是一张大饼，只要尽量把这张饼摊得越大就能养活更多的人，所以理所应当的尽一切力量去推动经济的发展。过于关注摊大饼的结果就是，在发展的过程中忽略了其它许多重要的东西，例如维持社会平等、确保生态和谐、维持底层群众的上升通道等。</p>
<p>科学的力量只是在近代才获得了最完美的体现，其实早期的人类发展中，之所以无法用科学来推动增长，是因为大家误以为各种宗教经典和古老传统里已经提供了世界上所有的重要知识。近代科学真正爆发的原因就是，科学让人类发现了自己的无知。人类发现自己对这个真实的世界所知甚少，就突然有了很好的理由去追求新知识，开启了用科学推动进步的道路。</p>
<h4 id="人文主义革命"><a href="#人文主义革命" class="headerlink" title="人文主义革命"></a>人文主义革命</h4><p>人文主义把意义和权威的源头从天上转移到人类的内心，这个宇宙的本质也随之改变了。人文主义者认为生命就是一种内在的渐进变化过程，靠着经验，让人从无知走向启蒙。人文主义生活的最高目标，就是通过各式智力、情绪及身体体验，充分发展人的知识。人文主义相信自己的“感觉”，于是我们在与现代性的契约中虽然得利，却无须付出代价。所有的规则，以及远古的上帝都从人民的脑中移除，现在对于任何有关价值观的判断，并没有绝对的是非之分，比如古代同性恋会遭到整个社会的鄙视，而现在呢？管他呢，你觉得舒服，那就做吧，你是同性恋，还不能鄙视你，否则就涉嫌歧视了，所有的判断出发点都是人的主观感受。再比如雇佣童工在早期的资本主义世界很是普遍，现在为什么行不通了？因为虚伪的道德主义逼迫着人去同情这些孩子，并从孩子的角度出发去思考，孩子正在玩乐的年纪却要呆在工厂里，简直丧尽天良，而真实情况呢？对于那些家庭极度贫困的来说，童工可能就是他们家庭的最大收入来源了，也未可知呢，这样从人心出发而不论对错的人文主义，占尽了表面的道德高点，却未必是最好的。</p>
<h4 id="实验室里的定时炸弹"><a href="#实验室里的定时炸弹" class="headerlink" title="实验室里的定时炸弹"></a>实验室里的定时炸弹</h4><p>所谓人类拥有的自由意识，在本书中作者给出了否定，并列举出了详细的证据，所谓的自由意识并不存在，无非是人类自己忽悠自己而已。人类有的就是一条意识流，欲望会在意识流中起伏来去，并没有什么永远不变的自我能够拥有这些欲望。自由意识流的本质不外乎两点，要么来自于生物预设，也就是说基因携带，天生所有；要么来自于随机发生，一切的自由意识并不是提前准备，而在某一个时刻将之释放出来的。说了这么多废话来证明人类没有自由意识到底是为何呢？如果这个证明正确，那么我们就可以利用药物、基因工程或者直接对脑做出刺激，就能操纵甚至控制人的欲望了。因为这并没有违反任何人类的天性，也没有改变人类的自由，所有利用科技手段对大脑实施的刺激控制等等都是合理且合法的。在过往的时期，自由主义还没有受到致命的威胁，现今面临着科技的进步，会给自由主义带来实实在在的挑战。我们即将拥有各种超级实用的设备、工具和制度，但这些设备、工具和制度并不允许个人自由意志的存在。</p>
<h4 id="大分离"><a href="#大分离" class="headerlink" title="大分离"></a>大分离</h4><p>自由主义面临着三个实际威胁，一是人类将完全不具价值；二是人类整体仍然有价值，但个人将不再具有权威，而是由外部算法来管理；三是有些人仍然会不可或缺，算法系统也难以了解，而且会形成一个人数极少的特权精英阶层，由升级后的人类组成。</p>
<p>如果科学发现和科技发展将人类分为两类，一类是绝大多数无用的普通人，另一类是一小部分经过升级的超人类，又或者各种事情的决定权已经完全从人类手中转移到具备高度智能的算法，在这两种情况下，自由主义都将崩溃。尽管现阶段所有人的共识是经济的发展使得穷人与富人的医疗水平差距在逐渐缩小，但这只是在特殊时代背景下的特殊情况，因为现代还需要大量的健康的士兵和产业工人，一旦科技的发展使得高精尖武器或者机器人取代士兵与产业工人，对于富人阶级来说，再继续维持庞大的底层人民的医疗开支将变成一笔巨大的负担，而这才是真正的转折点，当富人阶层不再需要依赖底层的大量人民的时候，不仅仅是医疗水平，各个方面，富人阶层都将开始起飞，而穷人阶层只能原地踏步，这导致的最终结果就是超人类阶层的出现，而这将会是全部由精英阶层所组成。</p>
<h4 id="意识的海洋"><a href="#意识的海洋" class="headerlink" title="意识的海洋"></a>意识的海洋</h4><p>这一章详尽地探讨了科技人文主义。科技人文主义希望让人类的心智升级，让我们能够接触到目前未知的经验、目前未闻的意识状态。然而想要足够地了解我们的心智已经是一项极其艰巨的任务，在人类目前所知的范围内，已经掌握的知识犹如沧海一粟，真正的未知世界浩瀚无边，在追求改造心智的过程中，也许我们成功地让身体与大脑都升级了，却在过程中失去了心智。科技人文主义到最后可能会造成人类的降级。</p>
<h4 id="信数据得永生"><a href="#信数据得永生" class="headerlink" title="信数据得永生"></a>信数据得永生</h4><p>在历史进程中，人类创造了一个全球性的网络，不论面对任何事物，都以它在这个网络中有何功能来给予评价。几千年来，这让人充满了自尊和偏见。人类在这个网络中执行着最重要的功能，也就很容易认为自己是这个网络所有成就的主要功臣，并认为自己就是造物的巅峰。至于其他所有动物，因为它们执行的只是网络中次要的功能，于是其生命和经验都遭到低估；只要动物不再能发挥任何功能，就躲不开惨遭灭绝的命运。然而，一旦人类对网络也不再能发挥重要功能，就会发现自己到头来也不是造物巅峰。我们自己设定的标准，会让我们也走上长毛象和白鱀豚的灭绝之路。到时回首过去，人类也只会成为宇宙数据流里的一片小小涟漪。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;尤瓦尔•赫拉利，1976年生，青年怪才，全球瞩目的新锐历史学家，牛津大学历史学博士，耶路撒冷希伯来大学历史系教授，著有国际畅销书《人类简史》。其新作《未来简史》，以宏大视角审视人类未来的终极命运，甫一出版就在全球掀起一股风潮，引起
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>使用DocumentStoredFieldVisitor提高Lucene检索速度</title>
    <link href="http://www.codepub.cn/2017/05/31/Improve-the-retrieval-speed-of-lucene-by-DocumentStoredFieldVisitor/"/>
    <id>http://www.codepub.cn/2017/05/31/Improve-the-retrieval-speed-of-lucene-by-DocumentStoredFieldVisitor/</id>
    <published>2017-05-31T13:42:38.000Z</published>
    <updated>2017-11-20T14:18:34.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="FieldSelector"><a href="#FieldSelector" class="headerlink" title="FieldSelector"></a>FieldSelector</h4><p>提高Lucene检索性能的方法有很多种，这里简单介绍一种常用且便捷可行的方法快速提高Lucene检索性能。在早期的Lucene版本中，使用<strong>FieldSelector</strong>来决定哪些Fields应该被加载，并以何种方式加载，但是在<a href="https://issues.apache.org/jira/browse/LUCENE-3309" target="_blank" rel="external">LUCENE-3309</a>中该接口被废弃，并且提出了新的替代接口<strong>StoredFieldVisitor</strong>。</p>
<h4 id="FieldCache"><a href="#FieldCache" class="headerlink" title="FieldCache"></a>FieldCache</h4><p>另一种提高检索性能的方案是使用FieldCache来缓存Lucene的term values信息，不过该接口目前已被移至<code>org.apache.lucene.uninverting</code>包下，并且访问权限变成包级私有，也就是说，用户再也无法直接使用FieldCache了，该接口以后仅限于Lucene内部使用。FieldCache的主要作用是缓存用来排序field的值，Lucene会将需要排序的字段都读到内存中进行排序，所占内存大小和文档数量相关。其替代方案是使用DocValues类。其实深入一步，当你的Document只有一个Token的时候，FieldCache还可以被用来快速获取每个Document的field值，因为Lucene只做了反向索引，这种Document-&gt;field正向索引是极其耗时的，而FieldCache正好能解决这个问题。</p>
<p>由于这两个接口基本相当于被废弃，这里不再赘述，主要讲解目前实用的<strong>StoredFieldVisitor</strong>方案。</p>
<h4 id="StoredFieldVisitor"><a href="#StoredFieldVisitor" class="headerlink" title="StoredFieldVisitor"></a>StoredFieldVisitor</h4><p>StoredFieldVisitor是一个抽象类，它有一个唯一对外暴露的实现类DocumentStoredFieldVisitor，查看该实现类的Doc文档说明，可知其作用是支持加载所有的stored fields，或者通过Set集合指定请求的fields。</p>
<p>查看DocumentStoredFieldVisitor构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentStoredFieldVisitor</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.fieldsToAdd = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentStoredFieldVisitor</span><span class="params">(Set&lt;String&gt; fieldsToAdd)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.fieldsToAdd = fieldsToAdd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Load only fields named in the provided fields. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentStoredFieldVisitor</span><span class="params">(String... fields)</span> </span>&#123;</div><div class="line">  fieldsToAdd = <span class="keyword">new</span> HashSet&lt;&gt;(fields.length);</div><div class="line">  <span class="keyword">for</span>(String field : fields) &#123;</div><div class="line">    fieldsToAdd.add(field);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个无参构造函数，一个接收Set参数的构造函数，还有一个接收可变参数的构造函数，而可变参数的构造函数中其实就是把可变参数加入Set集合，所以其原理和接收Set集合的构造函数是一样的。</p>
<p>讲了这么多，那么DocumentStoredFieldVisitor的使用场景是什么呢？当用户需要访问各个文档中的某个field的值时，使用IndexSearcher.doc(int docID)可以获得Document，然后再从Document中获得某个域值，当一个Document中field非常多的时候，这种访问速度比较慢，而且只能获得Stored域的值。这时候使用DocumentStoredFieldVisitor可以极大地提高访问速度。下面写个简单的测试代码来看看其性能差距。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</div><div class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomStringUtils;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.cjk.CJKAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.*;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.RAMDirectory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Created by wangxu on 2017/05/27 17:37.</div><div class="line"> * &lt;/p&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Description: 基于Lucene 6.5.0实现</div><div class="line"> * &lt;/p&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Wang Xu</div><div class="line"> * <span class="doctag">@version</span> V1.0.0</div><div class="line"> * <span class="doctag">@since</span> V1.0.0 &lt;br/&gt;</div><div class="line"> * WebSite: http://codepub.cn &lt;br&gt;</div><div class="line"> * Licence: Apache v2 License</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStoredFieldVisitor</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> IndexSearcher indexSearcher;</div><div class="line">    <span class="keyword">static</span> Query query;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RAMDirectory ramDirectory = <span class="keyword">new</span> RAMDirectory();</div><div class="line">        IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(ramDirectory, <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> CJKAnalyzer()));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</div><div class="line">            Document document = <span class="keyword">new</span> Document();</div><div class="line">            document.add(<span class="keyword">new</span> LongPoint(<span class="string">"ID"</span>, i));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"title"</span>, i + <span class="string">"title"</span>, Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, i + <span class="string">"content"</span>, Field.Store.YES));</div><div class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                document.add(<span class="keyword">new</span> StringField(<span class="string">"sex"</span>, <span class="string">"male"</span>, Field.Store.YES));</div><div class="line">                document.add(<span class="keyword">new</span> TextField(<span class="string">"tags"</span>, <span class="string">"The "</span> + i + <span class="string">"th male!"</span>, Field.Store.YES));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                document.add(<span class="keyword">new</span> StringField(<span class="string">"sex"</span>, <span class="string">"female"</span>, Field.Store.YES));</div><div class="line">                document.add(<span class="keyword">new</span> TextField(<span class="string">"tags"</span>, <span class="string">"The "</span> + i + <span class="string">"th female!"</span>, Field.Store.YES));</div><div class="line">            &#125;</div><div class="line">            document.add(<span class="keyword">new</span> TextField(<span class="string">"hobbies"</span>, <span class="string">"I like playing the "</span> + i + <span class="string">" toys!"</span>, Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField1"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField2"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField3"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField4"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField5"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField6"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField7"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            document.add(<span class="keyword">new</span> StringField(<span class="string">"testField8"</span>, RandomStringUtils.randomAlphabetic(<span class="number">10</span>), Field.Store.YES));</div><div class="line">            indexWriter.addDocument(document);</div><div class="line">        &#125;</div><div class="line">        indexWriter.commit();</div><div class="line">        indexWriter.close();</div><div class="line">        indexSearcher = <span class="keyword">new</span> IndexSearcher(DirectoryReader.open(ramDirectory));</div><div class="line">        query = LongPoint.newRangeQuery(<span class="string">"ID"</span>, <span class="number">0</span>, Math.addExact(<span class="number">1000000</span>, -<span class="number">1</span>));</div><div class="line">        <span class="keyword">int</span> count = indexSearcher.count(query);</div><div class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            Future&lt;Long&gt; submit = Executors.newSingleThreadExecutor().submit(<span class="keyword">new</span> Worker1(count));<span class="comment">//average time cost by 10 times : 8024 ms</span></div><div class="line">            <span class="comment">//Future&lt;Long&gt; submit = Executors.newSingleThreadExecutor().submit(new Worker2(count));//average time cost by 10 times : 6507 ms</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                total += submit.get();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"average time cost by 10 times : "</span> + total / <span class="number">10</span> + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker1</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            Stopwatch started = Stopwatch.createStarted();</div><div class="line">            List&lt;String&gt; titles = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                TopDocs docs = indexSearcher.search(query, count);</div><div class="line">                ScoreDoc[] scoreDocs = docs.scoreDocs;</div><div class="line">                <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">                    Document doc = indexSearcher.doc(scoreDoc.doc);</div><div class="line">                    titles.add(doc.get(<span class="string">"title"</span>));</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"No DocumentStoredFieldVisitor get title counts = "</span> + titles.size());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">long</span> elapsed = started.elapsed(TimeUnit.MILLISECONDS);</div><div class="line">            System.out.println(<span class="string">"No DocumentStoredFieldVisitor: "</span> + elapsed + <span class="string">" ms"</span>);</div><div class="line">            <span class="keyword">return</span> elapsed;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker2</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.count = count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            Stopwatch started = Stopwatch.createStarted();</div><div class="line">            Set&lt;String&gt; title = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            title.add(<span class="string">"title"</span>);</div><div class="line">            DocumentStoredFieldVisitor titleVisitor = <span class="keyword">new</span> DocumentStoredFieldVisitor(title);</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                TopDocs docs = indexSearcher.search(query, count);</div><div class="line">                ScoreDoc[] scoreDocs = docs.scoreDocs;</div><div class="line">                <span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">                    indexSearcher.doc(scoreDoc.doc, titleVisitor);</div><div class="line">                &#125;</div><div class="line">                Document document = titleVisitor.getDocument();</div><div class="line">                System.out.println(<span class="string">"With DocumentStoredFieldVisitor get title counts = "</span> + document.getValues(<span class="string">"title"</span>).length);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">long</span> elapsed = started.elapsed(TimeUnit.MILLISECONDS);</div><div class="line">            System.out.println(<span class="string">"With DocumentStoredFieldVisitor: "</span> + elapsed + <span class="string">" ms"</span>);</div><div class="line">            <span class="keyword">return</span> elapsed;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在索引1000000个文档之后，每个文档添加14个不同类型的Field，分别运行Worker1和Worker2，进行十次的基于ID的范围查询，取十次结果的平均值，得到使用DocumentStoredFieldVisitor平均单次耗时6507 ms，不使用DocumentStoredFieldVisitor平均单次耗时8024 ms。可见性能提升还是很可观的，当然该测试并不权威，但是可以给出一个简单直观的比较。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;FieldSelector&quot;&gt;&lt;a href=&quot;#FieldSelector&quot; class=&quot;headerlink&quot; title=&quot;FieldSelector&quot;&gt;&lt;/a&gt;FieldSelector&lt;/h4&gt;&lt;p&gt;提高Lucene检索性能的方法有很多种，这里简单介绍
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Lucene" scheme="http://www.codepub.cn/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>我的图书馆时光</title>
    <link href="http://www.codepub.cn/2017/05/23/my-library-time-in-SHU/"/>
    <id>http://www.codepub.cn/2017/05/23/my-library-time-in-SHU/</id>
    <published>2017-05-23T00:30:19.000Z</published>
    <updated>2017-11-20T14:18:34.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的图书馆时光"><a href="#我的图书馆时光" class="headerlink" title="我的图书馆时光"></a>我的图书馆时光</h3><p><strong>姓名</strong>：codepub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>学号</strong>：13721035&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>学院</strong>：计算机工程与科学学院</p>
<h4 id="一、入馆记录"><a href="#一、入馆记录" class="headerlink" title="一、入馆记录"></a>一、入馆记录</h4><p>2013年—2016年4月，一共到馆205次，第一次走进宝山校区图书馆是在2013年9月6日10时21分22秒。<br><img src="http://7xig3q.com1.z0.glb.clouddn.com/my_library_time_1.jpg" alt=""><br>13级硕士生平均入馆138.52次，我的次数是205次，我的入馆次数是平均次数的1.48倍。</p>
<h4 id="二、选座记录"><a href="#二、选座记录" class="headerlink" title="二、选座记录"></a>二、选座记录</h4><p>2013年—2013年10月，一共预约座位4次，第一次预约的是本部图书馆的二楼综合阅览（东区）的141号座位，时间在2013年9月6日10时23分1秒。<br><img src="http://7xig3q.com1.z0.glb.clouddn.com/my_library_time_2.jpg" alt=""></p>
<h4 id="三、上机记录"><a href="#三、上机记录" class="headerlink" title="三、上机记录"></a>三、上机记录</h4><p>您无上机记录。</p>
<h4 id="四、借还记录"><a href="#四、借还记录" class="headerlink" title="四、借还记录"></a>四、借还记录</h4><p>2013年—2015年10月，一共借还图书69本，我第一次借还的书籍是《语义Web技术基础》，借阅时间是2013年11月11日，我最后一次借还的书籍是《文明之光.:第三册》，借阅时间是2015年10月18日，我的借阅偏好是：专业技术。<br><img src="http://7xig3q.com1.z0.glb.clouddn.com/my_library_time_3.jpg" alt=""><br>13级硕士生人均借还30.76册，我借还图书69册，我的借阅量是平均量的2.24倍。</p>
<h4 id="五、我的借还清单"><a href="#五、我的借还清单" class="headerlink" title="五、我的借还清单"></a>五、我的借还清单</h4><table>
<thead>
<tr>
<th>序号</th>
<th>书名</th>
<th>作者</th>
<th>出版社</th>
<th>出版年</th>
<th>借阅时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>语义Web技术基础</td>
<td>Pascal Hitzler … [等] 著</td>
<td>清华大学出版社</td>
<td>2012</td>
<td>20131111</td>
</tr>
<tr>
<td>2</td>
<td>Hadoop实战</td>
<td>(美) Chuck Lam著</td>
<td>人民邮电出版社</td>
<td>2011</td>
<td>20131117</td>
</tr>
<tr>
<td>3</td>
<td>Hadoop实战</td>
<td>陆嘉恒著</td>
<td>机械工业出版社</td>
<td>2011</td>
<td>20131117</td>
</tr>
<tr>
<td>4</td>
<td>Lucene in action中文版</td>
<td>(美) Otis Gospodnetic, Erik Hatcher著</td>
<td>电子工业出版社</td>
<td>2007</td>
<td>20131117</td>
</tr>
<tr>
<td>5</td>
<td>解密搜索引擎技术实战 :Lucene &amp; Java精华版</td>
<td>罗刚编著</td>
<td>电子工业出版社</td>
<td>2011</td>
<td>20131117</td>
</tr>
<tr>
<td>6</td>
<td>Hadoop源代码分析</td>
<td>张鑫著</td>
<td>中国铁道出版社</td>
<td>2013</td>
<td>20131117</td>
</tr>
<tr>
<td>7</td>
<td>搜索引擎原理与实践</td>
<td>袁津生, 李群, 蔡岳编著</td>
<td>北京邮电大学出版社</td>
<td>2008</td>
<td>20131117</td>
</tr>
<tr>
<td>8</td>
<td>数据挖掘原理与算法</td>
<td>邵峰晶 … [等] 编著</td>
<td>科学出版社</td>
<td>2009</td>
<td>20131117</td>
</tr>
<tr>
<td>9</td>
<td>大数据时代的历史机遇 :产业变革与数据科学</td>
<td>赵国栋 … [等] 著</td>
<td>清华大学出版社</td>
<td>2013</td>
<td>20131117</td>
</tr>
<tr>
<td>10</td>
<td>自己动手写网络爬虫</td>
<td>罗刚, 王振东编著</td>
<td>清华大学出版社</td>
<td>2010</td>
<td>20131117</td>
</tr>
<tr>
<td>11</td>
<td>增长的极限 :the 30-year update</td>
<td>(美) 德内拉·梅多斯, 乔根·兰德斯, 丹尼斯·梅多斯著</td>
<td>机械工业出版社</td>
<td>2006</td>
<td>20131117</td>
</tr>
<tr>
<td>12</td>
<td>大数据挑战与NoSQL数据库技术</td>
<td>陆嘉恒编著</td>
<td>电子工业出版社</td>
<td>2013</td>
<td>20131117</td>
</tr>
<tr>
<td>13</td>
<td>迅速搭建全文搜索平台 :开源搜索引擎实战教程</td>
<td>于天恩编著</td>
<td>清华大学出版社</td>
<td>2007</td>
<td>20131117</td>
</tr>
<tr>
<td>14</td>
<td>数据挖掘与数据化运营实战 :思路、方法、技巧与应用</td>
<td>卢辉著</td>
<td>机械工业出版社</td>
<td>2013</td>
<td>20131117</td>
</tr>
<tr>
<td>15</td>
<td>Web 3.0 :互联网的语义革命 :the power of the Semantic Web to transform your business</td>
<td>(美) 大卫·西格尔著</td>
<td>科学出版社</td>
<td>2013</td>
<td>20131128</td>
</tr>
<tr>
<td>16</td>
<td>计算智能 :理论、技术与应用</td>
<td>丁永生编著</td>
<td>科学出版社</td>
<td>2004</td>
<td>20131128</td>
</tr>
<tr>
<td>17</td>
<td>PHP开发宝典</td>
<td>刘欣, 李慧等编著</td>
<td>机械工业出版社</td>
<td>2012</td>
<td>20131128</td>
</tr>
<tr>
<td>18</td>
<td>物联网关键技术</td>
<td>徐勇军, 刘禹, 王峰编著</td>
<td>电子工业出版社</td>
<td>2012</td>
<td>20131128</td>
</tr>
<tr>
<td>19</td>
<td>下一代互联网</td>
<td>吴建平, 李星主编</td>
<td>电子工业出版社</td>
<td>2012</td>
<td>20131128</td>
</tr>
<tr>
<td>20</td>
<td>物联网与云计算</td>
<td>张为民, 赵立君, 刘玮编著</td>
<td>电子工业出版社</td>
<td>2012</td>
<td>20131128</td>
</tr>
<tr>
<td>21</td>
<td>互联网之美</td>
<td>张浩编著</td>
<td>清华大学出版社</td>
<td>2013</td>
<td>20131128</td>
</tr>
<tr>
<td>22</td>
<td>QQ帮主 :马化腾其人</td>
<td>刘世英, 李良忠著</td>
<td>经济日报出版社</td>
<td>2010</td>
<td>20131202</td>
</tr>
<tr>
<td>23</td>
<td>马化腾谈创业与管理</td>
<td>谢森任著</td>
<td>海天出版社</td>
<td>2011</td>
<td>20131202</td>
</tr>
<tr>
<td>24</td>
<td>十亿美金的教训</td>
<td>林军, 唐宏梅著</td>
<td>浙江大学出版社</td>
<td>2011</td>
<td>20131202</td>
</tr>
<tr>
<td>25</td>
<td>企鹅凶猛 :马化腾的中国功夫</td>
<td>薛芳著</td>
<td>华文出版社</td>
<td>2009</td>
<td>20131202</td>
</tr>
<tr>
<td>26</td>
<td>中国互联网风云16年</td>
<td>武帅著</td>
<td>机械工业出版社</td>
<td>2011</td>
<td>20131202</td>
</tr>
<tr>
<td>27</td>
<td>矛盾与出路 :网络时代的文化价值观 :cultural values in the internet era</td>
<td>金民卿, 王佳菲, 梁孝著</td>
<td>经济科学出版社</td>
<td>2013</td>
<td>20131214</td>
</tr>
<tr>
<td>28</td>
<td>问道云计算</td>
<td>王鹏著</td>
<td>人民邮电出版社</td>
<td>2011</td>
<td>20131214</td>
</tr>
<tr>
<td>29</td>
<td>大数据时代 :生活、工作与思维的大变革 :a revolution that will transform how we live,</td>
<td>(英) 维克托·迈尔-舍恩伯格, 肯尼思·库克耶著</td>
<td>浙江人民出版社</td>
<td>2013</td>
<td>20131214</td>
</tr>
<tr>
<td>30</td>
<td>云计算 :深刻改变未来</td>
<td>张为民 … [等] 编著</td>
<td>科学出版社</td>
<td>2009</td>
<td>20131214</td>
</tr>
<tr>
<td>31</td>
<td>基于认知与计算的事件语义学研究</td>
<td>刘茂福, 胡慧君著</td>
<td>科学出版社</td>
<td>2013</td>
<td>20131214</td>
</tr>
<tr>
<td>32</td>
<td>语义Web原理及应用</td>
<td>高志强 … [等] 编著</td>
<td>机械工业出版社</td>
<td>2009</td>
<td>20131214</td>
</tr>
<tr>
<td>33</td>
<td>语义网、社会网络计算与Web资源共享</td>
<td>王莉著</td>
<td>电子工业出版社</td>
<td>2011</td>
<td>20131214</td>
</tr>
<tr>
<td>34</td>
<td>语义网原理与技术</td>
<td>陆建江 … [等] 编著</td>
<td>科学出版社</td>
<td>2007</td>
<td>20131214</td>
</tr>
<tr>
<td>35</td>
<td>Semantic web for the working ontologist : modeling in RDF, RDFS and OWL = 实用语义网 : RDFS与O</td>
<td>Allemang, Dean.</td>
<td>Beijing : Posts &amp; Telecom Press, 2009.</td>
<td>2009</td>
<td>20131214</td>
</tr>
<tr>
<td>36</td>
<td>语义Web技术基础</td>
<td>Pascal Hitzler … [等] 著</td>
<td>清华大学出版社</td>
<td>2012</td>
<td>20131219</td>
</tr>
<tr>
<td>37</td>
<td>Head First PHP &amp; MySQL</td>
<td>Lynn Beighley, Michael Morrison著</td>
<td>中国电力出版社</td>
<td>2010</td>
<td>20131219</td>
</tr>
<tr>
<td>38</td>
<td>云计算与分布式系统 :从并行处理到物联网 :from parallel processing to the internet o</td>
<td>(美) Kai Hwang, Geoffrey C. Fox, Jack J. Dongarra著</td>
<td>机械工业出版社</td>
<td>2013</td>
<td>20131229</td>
</tr>
<tr>
<td>39</td>
<td>新概念英语语法新思维.:第四册</td>
<td>梅雪主编</td>
<td>中国石化出版社</td>
<td>2010</td>
<td>20131229</td>
</tr>
<tr>
<td>40</td>
<td>程序员的数学</td>
<td>(日) 结城浩著</td>
<td>人民邮电出版社</td>
<td>2012</td>
<td>20131229</td>
</tr>
<tr>
<td>41</td>
<td>新概念英语语法新思维.:第三册</td>
<td>新概念英语学习中心编</td>
<td>中国石化出版社</td>
<td>2010</td>
<td>20131229</td>
</tr>
<tr>
<td>42</td>
<td>精通Spring :Java轻量级架构开发实践</td>
<td>孟劼编著</td>
<td>人民邮电出版社</td>
<td>2006</td>
<td>20131229</td>
</tr>
<tr>
<td>43</td>
<td>Hadoop技术内幕,:深入解析Hadoop Common和HDFS架构设计与实现原理 :in-depth study of C</td>
<td>蔡斌, 陈湘萍著</td>
<td>机械工业出版社</td>
<td>2013</td>
<td>20131229</td>
</tr>
<tr>
<td>44</td>
<td>数据挖掘原理与算法</td>
<td>邵峰晶 … [等] 编著</td>
<td>科学出版社</td>
<td>2009</td>
<td>20140105</td>
</tr>
<tr>
<td>45</td>
<td>Lucene in action中文版</td>
<td>(美) Otis Gospodnetic, Erik Hatcher著</td>
<td>电子工业出版社</td>
<td>2007</td>
<td>20140105</td>
</tr>
<tr>
<td>46</td>
<td>语义Web技术基础</td>
<td>Pascal Hitzler … [等] 著</td>
<td>清华大学出版社</td>
<td>2012</td>
<td>20140219</td>
</tr>
<tr>
<td>47</td>
<td>Hadoop技术内幕,:深入解析Hadoop Common和HDFS架构设计与实现原理 :in-depth study of C</td>
<td>蔡斌, 陈湘萍著</td>
<td>机械工业出版社</td>
<td>2013</td>
<td>20140219</td>
</tr>
<tr>
<td>48</td>
<td>精通Spring :Java轻量级架构开发实践</td>
<td>孟劼编著</td>
<td>人民邮电出版社</td>
<td>2006</td>
<td>20140219</td>
</tr>
<tr>
<td>49</td>
<td>Lucene in action中文版</td>
<td>(美) Otis Gospodnetic, Erik Hatcher著</td>
<td>电子工业出版社</td>
<td>2007</td>
<td>20140219</td>
</tr>
<tr>
<td>50</td>
<td>基于认知与计算的事件语义学研究</td>
<td>刘茂福, 胡慧君著</td>
<td>科学出版社</td>
<td>2013</td>
<td>20140219</td>
</tr>
<tr>
<td>51</td>
<td>编译原理 :编译程序构造与实践</td>
<td>张幸儿编著</td>
<td>机械工业出版社</td>
<td>2008</td>
<td>20140325</td>
</tr>
<tr>
<td>52</td>
<td>编译原理</td>
<td>主编王磊, 胡元义</td>
<td>科学出版社</td>
<td>2009</td>
<td>20140325</td>
</tr>
<tr>
<td>53</td>
<td>基于认知与计算的事件语义学研究</td>
<td>刘茂福, 胡慧君著</td>
<td>科学出版社</td>
<td>2013</td>
<td>20140325</td>
</tr>
<tr>
<td>54</td>
<td>编译原理及实现</td>
<td>孙悦红编著</td>
<td>清华大学出版社</td>
<td>2011</td>
<td>20140325</td>
</tr>
<tr>
<td>55</td>
<td>编译原理及编译程序构造</td>
<td>薛联凤, 秦振松编著</td>
<td>东南大学出版社</td>
<td>2013</td>
<td>20140325</td>
</tr>
<tr>
<td>56</td>
<td>C++程序设计教程</td>
<td>钱能主编</td>
<td>清华大学出版社</td>
<td>1999</td>
<td>20140325</td>
</tr>
<tr>
<td>57</td>
<td>新概念英语词汇精典.:4</td>
<td>主编金利</td>
<td>北京语言大学出版社</td>
<td>2010</td>
<td>20140325</td>
</tr>
<tr>
<td>58</td>
<td>新概念英语词汇精典.:3</td>
<td>主编金利</td>
<td>北京语言大学出版社</td>
<td>2010</td>
<td>20140325</td>
</tr>
<tr>
<td>59</td>
<td>单词记忆大革命 :用耳朵记单词,:CET-6</td>
<td>金莉</td>
<td>世界图书出版公司</td>
<td>2007</td>
<td>20140325</td>
</tr>
<tr>
<td>60</td>
<td>精通Spring :Java轻量级架构开发实践</td>
<td>孟劼编著</td>
<td>人民邮电出版社</td>
<td>2006</td>
<td>20140414</td>
</tr>
<tr>
<td>61</td>
<td>Lucene in action中文版</td>
<td>(美) Otis Gospodnetic, Erik Hatcher著</td>
<td>电子工业出版社</td>
<td>2007</td>
<td>20140414</td>
</tr>
<tr>
<td>62</td>
<td>语义Web技术基础</td>
<td>Pascal Hitzler … [等] 著</td>
<td>清华大学出版社</td>
<td>2012</td>
<td>20140414</td>
</tr>
<tr>
<td>63</td>
<td>新概念英语词汇精典.:3</td>
<td>主编金利</td>
<td>北京语言大学出版社</td>
<td>2010</td>
<td>20140511</td>
</tr>
<tr>
<td>64</td>
<td>新概念英语词汇精典.:4</td>
<td>主编金利</td>
<td>北京语言大学出版社</td>
<td>2010</td>
<td>20140511</td>
</tr>
<tr>
<td>65</td>
<td>基于认知与计算的事件语义学研究</td>
<td>刘茂福, 胡慧君著</td>
<td>科学出版社</td>
<td>2013</td>
<td>20140511</td>
</tr>
<tr>
<td>66</td>
<td>Java web典型模块与项目实战大全 :49.5小时多媒体教学视频</td>
<td>常建功等编著</td>
<td>清华大学出版社</td>
<td>2011</td>
<td>20150316</td>
</tr>
<tr>
<td>67</td>
<td>英语思维是这样炼成的</td>
<td>王乐平著</td>
<td>华南理工大学出版社</td>
<td>2010</td>
<td>20150316</td>
</tr>
<tr>
<td>68</td>
<td>文明之光.:第二册</td>
<td>吴军著</td>
<td>人民邮电出版社</td>
<td>2014</td>
<td>20151018</td>
</tr>
<tr>
<td>69</td>
<td>文明之光.:第三册</td>
<td>吴军著</td>
<td>人民邮电出版社</td>
<td>2014</td>
<td>20151018</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我的图书馆时光&quot;&gt;&lt;a href=&quot;#我的图书馆时光&quot; class=&quot;headerlink&quot; title=&quot;我的图书馆时光&quot;&gt;&lt;/a&gt;我的图书馆时光&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt;：codepub&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 拉取海量数据报 OutOfMemoryError</title>
    <link href="http://www.codepub.cn/2017/05/12/MySQL-pull-the-massive-data-out-of-memory-error/"/>
    <id>http://www.codepub.cn/2017/05/12/MySQL-pull-the-massive-data-out-of-memory-error/</id>
    <published>2017-05-12T14:40:37.000Z</published>
    <updated>2017-11-20T14:18:34.053Z</updated>
    
    <content type="html"><![CDATA[<p>在用最基本的<code>JDBC</code>拉取数据的时候，由于拉取的是海量数据，所以程序跑了一段时间之后报<code>java.lang.OutOfMemoryError: Java heap space</code>，这个错误很简单，也很好解决，网上一搜一大把，只需要设置<code>ResultSet</code>获取数据模式为<code>row-by-row</code>，但是总结多数的解决方案是如下两种：<br>① 以PreparedStatement为例，需要设置四个参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preparedStatement = connection.prepareStatement(formatSql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</div><div class="line">preparedStatement.setFetchSize(Integer.MIN_VALUE);</div><div class="line">preparedStatement.setFetchDirection(ResultSet.FETCH_REVERSE);</div></pre></td></tr></table></figure></p>
<p>② 同样以PreparedStatement为例，需要设置三个参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">preparedStatement = connection.prepareStatement(formatSql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</div><div class="line">preparedStatement.setFetchSize(Integer.MIN_VALUE);</div></pre></td></tr></table></figure></p>
<p>这种解决方案是可以的，那么本文还有无存在的必要呢？当然有。这两种方案基本上都是参看MySQL官方说明来解决的，具体链接<a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-implementation-notes.html" target="_blank" rel="external">点我</a>，内容摘录如下</p>
<blockquote>
<p>By default, ResultSets are completely retrieved and stored in memory. In most cases this is the most efficient way to operate and, due to the design of the MySQL network protocol, is easier to implement. If you are working with ResultSets that have a large number of rows or large values and cannot allocate heap space in your JVM for the memory required, you can tell the driver to stream the results back one row at a time.</p>
<p>To enable this functionality, create a Statement instance in the following manner:</p>
<p>stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);<br>stmt.setFetchSize(Integer.MIN_VALUE);</p>
<p>The combination of a forward-only, read-only result set, with a fetch size of Integer.MIN_VALUE serves as a signal to the driver to stream result sets row-by-row. After this, any result sets created with the statement will be retrieved row-by-row.</p>
<p>There are some caveats with this approach. You must read all of the rows in the result set (or close it) before you can issue any other queries on the connection, or an exception will be thrown.</p>
<p>The earliest the locks these statements hold can be released (whether they be MyISAM table-level locks or row-level locks in some other storage engine such as InnoDB) is when the statement completes.</p>
<p>If the statement is within scope of a transaction, then locks are released when the transaction completes (which implies that the statement needs to complete first). As with most other databases, statements are not complete until all the results pending on the statement are read or the active result set for the statement is closed.</p>
<p>Therefore, if using streaming results, process them as quickly as possible if you want to maintain concurrent access to the tables referenced by the statement producing the result set.</p>
</blockquote>
<p>但是我想说，其实一个参数就足矣。只需要设置<code>fetch size</code>为<code>Integer.MIN_VALUE</code>即可。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">preparedStatement = connection.prepareStatement(formatSql);</div><div class="line">preparedStatement.setFetchSize(Integer.MIN_VALUE);</div></pre></td></tr></table></figure></p>
<p>这样为什么可以呢？我们来看源码，点开prepareStatement的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mysql.jdbc;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">extends</span> <span class="title">ConnectionPropertiesImpl</span> <span class="keyword">implements</span> <span class="title">MySQLConnection</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prepareStatement(sql, <span class="number">1003</span>, <span class="number">1007</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到即使你调用的是<code>prepareStatement(formatSql)</code>，但是在实现中调用的是<code>prepareStatement(sql, 1003, 1007)</code>，而<code>ResultSet.TYPE_FORWARD_ONLY = 1003</code>，<code>ResultSet.CONCUR_READ_ONLY = 1007</code>，所以不需要在调用的时候传递<code>TYPE_FORWARD_ONLY</code>和<code>CONCUR_READ_ONLY</code>。</p>
<p>再来看<code>setFetchDirection</code>的具体实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mysql.jdbc;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementImpl</span> <span class="keyword">implements</span> <span class="title">Statement</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFetchDirection</span><span class="params">(<span class="keyword">int</span> direction)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(direction) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1000</span>:</div><div class="line">        <span class="keyword">case</span> <span class="number">1001</span>:</div><div class="line">        <span class="keyword">case</span> <span class="number">1002</span>:</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">"Statement.5"</span>), <span class="string">"S1009"</span>, <span class="keyword">this</span>.getExceptionInterceptor());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可知，在实现中，当<code>direction</code>值是1000、1001和1002时，其处理逻辑是一样的，那么这些值表示什么意思呢？在<code>ResultSet</code>类中可以查到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> FETCH_FORWARD = <span class="number">1000</span>;</div><div class="line"><span class="keyword">int</span> FETCH_REVERSE = <span class="number">1001</span>;</div><div class="line"><span class="keyword">int</span> FETCH_UNKNOWN = <span class="number">1002</span>;</div></pre></td></tr></table></figure></p>
<p>所以再调用<code>preparedStatement.setFetchDirection(ResultSet.FETCH_REVERSE);</code>这一句其实完全没必要，因为不论你传递的是哪个值，其结果都是相同的，所以说，使用流式结果集获取海量数据一个参数足矣，不要迷信网上二手信息，同样不要迷信官网，只有源码最靠谱。</p>
<p>如果想继续深究，可以查看MySQL判断是否开启流式结果集的方法，实现如下，判断逻辑很简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mysql.jdbc;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementImpl</span> <span class="keyword">implements</span> <span class="title">Statement</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">createStreamingResultSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resultSetType == <span class="number">1003</span> &amp;&amp; <span class="keyword">this</span>.resultSetConcurrency == <span class="number">1007</span> &amp;&amp; <span class="keyword">this</span>.fetchSize == -<span class="number">2147483648</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用最基本的&lt;code&gt;JDBC&lt;/code&gt;拉取数据的时候，由于拉取的是海量数据，所以程序跑了一段时间之后报&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;，这个错误很简单，也很好解决，网上一搜一大把，只需要
    
    </summary>
    
      <category term="Database" scheme="http://www.codepub.cn/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://www.codepub.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Gradle使用扩展属性管理依赖版本号</title>
    <link href="http://www.codepub.cn/2017/05/09/Gradle-uses-extended-attributes-to-manage-dependent-version-numbers/"/>
    <id>http://www.codepub.cn/2017/05/09/Gradle-uses-extended-attributes-to-manage-dependent-version-numbers/</id>
    <published>2017-05-09T13:15:19.000Z</published>
    <updated>2017-11-20T14:18:34.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Maven预设变量"><a href="#Maven预设变量" class="headerlink" title="Maven预设变量"></a>Maven预设变量</h4><p>使用过<code>Maven</code>的人应该都知道，我们在<code>Maven</code>项目中添加依赖的一般性做法。就是打开<code>pom.xml</code>文件，在<code>&lt;dependencies&gt;</code>节点下添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>包含坐标和版本号的内容，那么在<code>Java</code>类文件中，就可以引用<code>Lucene</code>包中的各种类了。但是要注意一点，这里面的版本号是以硬编码的形式存在，作为一个合格的软件开发者，要尽量在你的代码中避免硬编码的情况。为什么呢？比如我需要依赖其它的<code>Lucene</code>模块，那么<code>pom.xml</code>中添加内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queries<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>假设经年累月，项目需要升级，<code>Lucene</code>的新版本也已发布，那么是不是需要手动修改每一行<code>&lt;version&gt;5.5.0&lt;/version&gt;</code>呢？这还只是依赖几个模块的问题，假设你依赖成百上千个模块，其版本号都需要升级，是不是觉得想抽当初的自己呢？其实在<code>Maven</code>中这种情况很好解决、就是利用预设变量。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version.lucene</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">version.lucene</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.lucene&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.lucene&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.lucene&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.lucene&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queries<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.lucene&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么以后再遇到项目升级的情况，只需要手动修改<code>&lt;version.lucene&gt;6.0.0&lt;/version.lucene&gt;</code>一行代码即可搞定，所有引用到该版本变量的依赖都自动升级，这样来管理依赖，是不是很哈皮呢？</p>
<h4 id="Gradle单模块"><a href="#Gradle单模块" class="headerlink" title="Gradle单模块"></a>Gradle单模块</h4><p>同样作为后起之秀的<code>Gradle</code>如何优雅地解决类似问题呢？硬编码的写法如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile "org.apache.lucene:lucene-core:5.5.0"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优雅的写法①如下，打开<code>build.gradle</code>文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">    luceneVersion = '6.5.0'</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">    compile "org.apache.lucene:lucene-core:$luceneVersion"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一定要注意包含<code>$</code>符号时，要用双引号，我就因用单引号在这上吃过亏。在<code>Gradle</code>中单引号和双引号都是合法的，但是略有不同。单引号中的内容严格对应<code>Java</code>中的<code>String</code>，不对<code>$</code>符号进行转义。双引号的内容则和脚本语言处理有点像，如果字符中有<code>$</code>号的话，则它会先对<code>$</code>表达式求值。在<code>Gradle</code>中，其实还有三引号的情形，这代表什么呢？三引号中的字符串支持任意换行，比如<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def multieLines = ''' begin</div><div class="line">  line  1</div><div class="line">  line  2</div><div class="line">  line  3</div><div class="line">  end '''</div></pre></td></tr></table></figure></p>
<p>除了①，还有优雅的写法②，使用字典类型，修改<code>build.gradle</code>文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">    javaSourceCompatibility = '1.8'</div><div class="line">    libVersions = [</div><div class="line">            junit : '4.12',</div><div class="line">            lucene: '6.5.0',</div><div class="line">            guava : '20.0'</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">    compile "junit:junit:$libVersions.junit"</div><div class="line">    compile "com.google.guava:guava:$libVersions.guava"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Gradle多模块"><a href="#Gradle多模块" class="headerlink" title="Gradle多模块"></a>Gradle多模块</h4><p>当在一个根项目下有多个子模块，那么一种简单的做法是在每个子模块中都定义<code>ext</code>代码块，声明需要使用到的版本号变量，这样做当然可以。但是当遇到需要升级版本号的情况时，需要手动修改所有的子模块，其实还有更优雅的解决方案。就是在根项目中定义<code>ext</code>代码块，打开根项目的<code>build.gradle</code>定义<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">    luceneVersion = '6.5.0'</div><div class="line">    libVersions = [</div><div class="line">            junit : '4.12',</div><div class="line">            guava : '20.0'</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在每个子模块的<code>build.gradle</code>中都可以直接引用之，方式如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile "junit:junit:$&#123;rootProject.libVersions.junit&#125;"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，当需要升级版本号的时候，只需要升级根项目中的变量即可，所用子模块的版本号会自动升级。</p>
<h4 id="消除Gradle编译警告"><a href="#消除Gradle编译警告" class="headerlink" title="消除Gradle编译警告"></a>消除Gradle编译警告</h4><p>通过Gradle编译项目过程中，有时会报如下警告信息</p>
<blockquote>
<p>注: xxx.java使用或覆盖了已过时的 API。<br>注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。<br>注: xxx.java使用了未经检查或不安全的操作。<br>注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</p>
</blockquote>
<p>警告不是Error，虽然不影响编译，但是看着总是不舒服，所以想办法消除警告信息。根据StackOverflow上的<a href="http://stackoverflow.com/questions/18689365/how-to-add-xlintunchecked-to-my-android-gradle-based-project" target="_blank" rel="external">问答</a>，在<code>build.gradle</code>中添加如下配置即可消除警告。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    gradle.projectsEvaluated &#123;</div><div class="line">        tasks.withType(JavaCompile) &#123;</div><div class="line">            options.compilerArgs &lt;&lt; "-Xlint:unchecked" &lt;&lt; "-Xlint:deprecation"</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Maven预设变量&quot;&gt;&lt;a href=&quot;#Maven预设变量&quot; class=&quot;headerlink&quot; title=&quot;Maven预设变量&quot;&gt;&lt;/a&gt;Maven预设变量&lt;/h4&gt;&lt;p&gt;使用过&lt;code&gt;Maven&lt;/code&gt;的人应该都知道，我们在&lt;code&gt;Mave
    
    </summary>
    
      <category term="Programming Notes" scheme="http://www.codepub.cn/categories/Programming-Notes/"/>
    
    
      <category term="Gradle" scheme="http://www.codepub.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>人民的名义</title>
    <link href="http://www.codepub.cn/2017/05/06/The-name-of-the-people/"/>
    <id>http://www.codepub.cn/2017/05/06/The-name-of-the-people/</id>
    <published>2017-05-06T14:28:03.000Z</published>
    <updated>2017-11-20T14:18:34.008Z</updated>
    
    <content type="html"><![CDATA[<p>一不小心，追了一个剧《人民的名义》，随着剧情一点一点地推进，突然开始很心疼，心疼的不是别人，也不是剧中的人物，因为那毕竟是虚构的，不是真实的人生，而是我们自己，这才是真真实实的生活与生命。看了剧中的情节，真是大开眼界，不论是祁同伟的一人得道，鸡犬升天，还是赵瑞龙的草菅人命亦或是丁义珍在饭局上左右逢源，逢场作戏，近似人生赢家。甚至一个处级干部赵德汉，都能狂贪几个亿，要知道，除了国家级领导人，下面就是部司厅局处科，小小一个处级干部，都能贪污几个亿？你知道天朝有多少处级干部吗？呵呵，我还真查了下，毛爷爷说，没有调查就没有发言权，参考链接在<a href="https://www.zhihu.com/question/23916966?sort=created" target="_blank" rel="external">这里</a>，处级干部约60万，一个人一亿的话，不敢想象，当然了，不能这么悲观，要相信党相信政府，我还是有这觉悟的。现如今大家都说日子难过，现在知道了吧？为什么我们日子难过了，在人民的名义中各种现象也只是社会真实情况的冰山一角吧？假设现实情况比电视剧中所要努力描绘的良好社会略槽糕一点点，那么日子难就很正常了，我想说，不正常才奇怪哩。</p>
<p>现在好多人都说房价高，那么房价为什么会高呢？只有两种情况，一种是你赚钱的速度赶不上房价的上涨速度，另一种是货币贬值了，房价虚高，只不过刚需接盘侠们是货币贬值的最后承受者，没有享受到任何一点点货币贬值带来的收益，要知道货币贬值对所有人来说并不是公平的，有人说，我手里的钱贬值了，那有钱人手里的钱一样也贬值了呀？只能说你too young，too simple，钱就像是流水，就像一条河，同样的一河水，在水的上游和下游能一样吗？同样货币这个贬值链，就像一条河水一样，也分上游下游，货币流到上游的人的手里的时候，并没有贬值，而是和以前价值一样，那么这些占据上游的都是哪些人呢？发大水的是央行，上游的人是各大国有银行、国企、国家各部委、权力掌控者等，中游是商业银行、民营企业、利益既得者等，经过层层盘剥，当这个贬值链流到下游的时候，又是哪些人呢？就是这个底层劳动人民、刚需接盘侠，之所以房价会高涨，是因为没有任何一个产业能够锁住这么海量的贬值货币，唯有将这些海量的货币存之于楼市，才能尽量减少对其他行业的伤害，试想通胀不是流向楼市，而是流向日常生活必须品，那个个吃不上饭可是天大的问题了，但是一部分人住不上房却不是致命的，即使这些住不上房的人闹腾也不用操心，因为那些有房的会代政府来管教他们，你说此话怎讲，君不见，房价略降，全国各地的售楼处都出现了业主打砸情况吗？这不就是有房产者、既得利益者在代国家管教这些无房产者吗？房价想降很难，一是政府不愿意，房价降了，海量的贬值货币往哪藏呢？二是有产者不愿意，买不起房，大家不会联合起来打砸售楼处，但是房价下降，已买房的人则会联合起来上书政府，要求政府救市，更有甚者，直接联合起来打砸售楼处，还有天理吗？法制社会存在这种流氓行径？没有任何理由，就是因为房价下降，就可以任意耍流氓了？呵呵，这些人没有得到严肃的处理，已经代表了政府的态度，睁一只眼闭一只眼，这些人就都没事了。</p>
<p>追剧的过程中，一把手在剧中出现了无数遍，我英文不好，不要欺负我，我想请问一把手英文怎么翻译呢？大英帝国、美帝国家人民的词典中，有一把手这个词吗？有海外待过的人，还望不吝赐教。民选政府与任命制有着本质的区别，民选出来的领导人要对人民负责，同理，任命制选出来的领导人只对任命他的人负责。这种本质的区别，注定了人民有着本质的不同地位，该得到什么样的对待都是自己争取而来，你笑着看资本主义国家人民游行、示威、罢工，那就不要忽视人家赢得的地位。有付出才有收获，老祖宗留下来的话，是有道理的。任命制在我看来只能听天由命了，就像古代皇帝一样，如果是个雄才大略、英明神武的皇帝，那么人民生活相对来说更幸福一点，如果碰到昏庸无能、荒淫无度的主，那人民的生活能不水深火热吗？这不就是靠天吃饭吗？和现在的任命制有啥区别？一把手喜欢你，就提拔你，至于你对人民来说是福是祸，又有几个一把手会关心呢？</p>
<p>这部剧叫《人民的名义》，恕我愚钝，我不知道这里面哪一点代表了人民的名义，我只看到草根出身的处长在第一集就被干掉了，我只看到同样草根出身的祁同伟和高小琴最后同样被干掉了，而那个利用权势不断打压祁同伟的人呢？梁璐包括他的父亲最后毫发无损，这就是人民的名义吗？人民的孩子总是最先和最后被干掉吗？我分明看到的就是有权有势同样能逍遥法外，我不知道现实中有多少丁义珍，但是我敢保证现实中的丁义珍绝对不会在国外的餐馆刷盘子，处处美化、处处讨喜，编剧们都不觉得恶心吗？像沙瑞金和侯亮平在现实中毕竟是少数，再进一步讲，现实中有多少丁义珍、赵立春（副国级，国家领导人啊、领导人啊、领导人啊）、赵瑞龙、刘新建、陈清泉等等这些人呢？恐怕远不止电视中所表现的那些吧？</p>
<p>在剧情最后部分，侯亮平劝降祁同伟，莫名的心疼起祁同伟来，那个和天下棋，愿用自己的命去胜天半子的人，也许在祁的心中是这么想的，你侯亮平算什么东西，也敢来劝降我？在祁的身边，虽然不乏师长，以及同一师门的师弟师妹，但是又有几个打心眼里瞧得起看得起他的呢？他想过靠自己的努力来出人头地，在大学里学习努力，成绩优异，并且还是校学生会主席，但是有什么用呢？毫无关系背景的他，眼睁睁的看着那些能力平平甚至低于他的的校友们分配到了大城市，而他却被掌控权力的梁璐的父亲下放到了穷山沟沟里，只因他没接受梁璐的追求，即便他没有放弃，主动请缨去做缉毒工作，因为这个工作更危险，更容易立功，凭借着过人的勇气和努力，他成为了缉毒英雄，但是结果呢？梁璐的父亲，凭借手握大权，借着权力以惜才为名义，阻止让他升迁，硬生生的将他继续困于穷山沟之中。最终，这个内心孤傲的人向现实屈服了，这才有了那在汉东大学的著名一跪，祁同伟啊是个被时代抛弃的人、是个被权力毁掉的人、是个草根出身不断向上爬却死在权力脚下的人，直到最后事发败露，他也没有屈服，用他的话说，这个世界上没有人能够审判他，即便可能被判无期徒刑，苟延残喘，但是并没有，他没有投降，没有屈服，而是选择自杀结束生命。</p>
<p>剧中还有一个现象被大家忽略了，那就是高育良和李达康的女儿都出国了，这就是官二代的命啊。而侯亮平和陈海这种所谓的中产呢？孩子只能挤在国内上些垃圾学校，甚至侯亮平妻子给孩子报的一个补习班，那老师居然是个电工，但是招生工作火热火热的，这和现代的学区房、各种补习班真是不谋而合。幸好这个老师被侯亮平一眼识破，谁又能说现实中存在诸多没有被识破的呢？如果现实中没有侯亮平去戳穿老师的嘴脸呢？岂不是依然可以大摇大摆的顶着补习班的名义继续招摇撞骗。如果现实中的所有官员子女都在国外接受教育，他们对人民又怎么会负责呢？从小接受资本主义国家的理念、文化、习俗、教育等等，怎么比得了土生土长的中国人对人民的了解程度呢？这些人谁又能保证其不在官爸爸富爸爸的扶持下走上统治人民的路子呢？当他们成长为了统治阶级，只要自我舒适，谁管你人民死活，大不了贪了几个亿全家移民罢了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一不小心，追了一个剧《人民的名义》，随着剧情一点一点地推进，突然开始很心疼，心疼的不是别人，也不是剧中的人物，因为那毕竟是虚构的，不是真实的人生，而是我们自己，这才是真真实实的生活与生命。看了剧中的情节，真是大开眼界，不论是祁同伟的一人得道，鸡犬升天，还是赵瑞龙的草菅人命亦
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>读《蚁族：大学毕业生聚居村实录》</title>
    <link href="http://www.codepub.cn/2017/04/25/Read-ant-tribe-college-graduates-live-in-the-village-record/"/>
    <id>http://www.codepub.cn/2017/04/25/Read-ant-tribe-college-graduates-live-in-the-village-record/</id>
    <published>2017-04-25T14:35:41.000Z</published>
    <updated>2017-11-20T14:18:34.143Z</updated>
    
    <content type="html"><![CDATA[<p>古有科举，今有高考，然今日境却不与古日同。科举自隋唐始，终于晚清，这是古代读书人唯一的上升通道，虽然说比较困难，但是最起码还是一个可行的通道，能让人对未来满怀憧憬。但当今时代，时移世易，在这个权利和人情的社会，越是“苦读”的平民家庭出身的孩子，机会可能越少。许多靠近权力的机关和垄断行业里，越来越没有平民和贫苦人家孩子的缘分。父辈的权力和“人脉”会以某种方式“世袭”。“蚁族”们大多来自农村和县级市，家庭收入低，他们的父母处于社会中下层。十年寒窗苦读得以让他们接受高等教育，但毕业时他们发现，由于自己没有“硬”关系，只能又回到“村”里。他们不是不努力不是不上进的一群人，能够从数千万底层劳动人民中脱颖而出，本身就说明了他们还是有所追求，有所渴望的，但是现实给予了他们重重一击，这一击足以让他们将人生中种种不如意，归因于这个社会，从而使自己喝社会对立起来。</p>
<p>人们说，现在是“知识经济”的时代。然而，蚁族们，接受了高等教育，却无法实现知识致富，甚至对某些人来说，找到一份糊口的工作都比较困难，这到底是自身不够努力？还是社会无法提供施展的平台？他们在社会上究竟处于怎样的位置？他们比传统的农民工幸福吗？难道他们千里迢迢来到大城市只为了体味生活的磨难？蚁族们有太多的故事值得述说，每个人虽然微若蝼蚁，但是都怀有各自那小小的梦想与希望。鲁迅先生说，希望本无所谓有，也无所谓无，这就像地上的路，其实地上本没有路，走的人多了，也便成了路。虽然现实有各种困难，但是对于蚁族们来说，心有多大，舞台才有多大。</p>
<p>在这本书中记录了大量采访对象身上的故事，看了他们的故事有时候也能看到自己的影子吧。不是不努力，不努力的人确实有，但是努力了依然看不到希望的恐怕才是主流吧，不能简单的把原因归咎于这些才毕业或者说毕业没有多久，也没啥能力的学生身上，大学的垃圾教育不足以培养他们在社会上谋生的手段，这又能怪的了谁呢？大学一直都是易出难进，至少在中国是这样的，而美国与此恰恰相反，美国的模式是易进难出，任何人都可以去读名校，但是四年本科毕业率极低，至少比中国低20个百分点吧。中国的大学就像是一股洪流，不是能够轻易改变的，任何置身其中的人，哪怕你能看到问题所在，你依然无能为力，你能做的只是尽量提高对自己的要求而已，仅此别无他法，只能被这股洪流裹挟着，浪费掉那谈不上多重的生命。</p>
<p>其实这些蚁族中也不乏有毅力、雄心、长远规划的人，而这些人多数都是男人，总的来说，在采访的蚁族中，每月一两千、两三千且月月光的女生居多，他们从心里上就认为自己是弱者，自己无需为以后考虑，更无需负担买房的压力，所以他们反而是过得更舒适的一类人，而另一类人呢？工资有的能到五六千，但是依然只蜗居在这每月几百块的破旧房子里，而舍不得租住更好的但价格更贵的房子，他们多数都是在默默地为了以后做这长远的打算。他们年纪都不大，却有更远大的目标，他们有能力使自己过得更好，却甘愿蜗居在这条件极差的城中村里，他们不在乎眼前的生活是否安逸。在这个世界上，他们将事业放在重要的位置。在他们看来，美好的梦想永远值得他们努力奋斗。</p>
<p>农村孩子在城市中等待翻身，如同等待铁树开花一样艰难。他们以考大学的方式告别农村，却至今仍无法融入城市的主流文化。物竞天择，家庭的负担和过低的起点，使农村的孩子无法轻装上阵。走出了老家的农村，又走进了北京的农村，这仿佛是一种宿命，萦绕着他们本该绽放的人生。然而他们没有退缩，在我看来，这些蜗居在城中村的人，心中依然保留着一份幻想，期待靠自己的努力，不断打拼，最终能够在这个城市立稳脚跟。可惜，现实是残酷的，他们终将成为北京的弃儿，我又何尝不是呢？一个人奋斗在魔都，满以为凭自己的努力可以奋斗出属于自己的一片天，如今想想，痴念罢了。不管是既得利益者，还是有产阶层，抑或统治阶级，都不可能轻易的让你成为这个全国顶尖城市的原住民。</p>
<p>大家想必都还记得曾经非常火热的《奋斗》吧？这些刚毕业就开上奥迪或奥拓的年轻人是否就是我们想象中的奋斗？如果这就是80后的奋斗，那这些城中村居住着的大学生难道都在混生活混日子？《奋斗》中那些俊男靓女们整天无所事事，打台球、泡吧的都市青年们究竟在为什么奋斗？其实，真正的生活中，这些住在“聚居村”里的“蚁族”正以实际行动诠释着“奋斗”的真正含义。刚毕业的他们面对生活显得捉襟见肘，但是这些能直面现实、接受现实的年轻人具有强大的精神动力，他们有自己的理想，而且正在积蓄力量为实现这些理想而奋斗。现实的分层是残酷的，《奋斗》的导演们以及里面的俊男靓女们其实并不知道什么才是真正源于生活的奋斗，那种从社会的底层不断向上爬，去努力撬动途径的每一个阶层所遇到的阻力与抗拒究竟有多大，他们是完全无法体会的，这部剧虽然很火，但是仅仅是富家公子顽劣青年的自我标榜与吹捧而已，他们并不理解艺术源于生活，更高于生活的真正含义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;古有科举，今有高考，然今日境却不与古日同。科举自隋唐始，终于晚清，这是古代读书人唯一的上升通道，虽然说比较困难，但是最起码还是一个可行的通道，能让人对未来满怀憧憬。但当今时代，时移世易，在这个权利和人情的社会，越是“苦读”的平民家庭出身的孩子，机会可能越少。许多靠近权力的机
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>水库论坛炒房多军欧神—欧成效</title>
    <link href="http://www.codepub.cn/2017/04/16/Reservoir-forum-elite-realtor-ouchengxiao/"/>
    <id>http://www.codepub.cn/2017/04/16/Reservoir-forum-elite-realtor-ouchengxiao/</id>
    <published>2017-04-16T02:55:50.000Z</published>
    <updated>2017-11-20T14:18:34.115Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欧神简介：</strong>姓欧名成效。出生于丁巳年癸丑月癸酉日。上海人，疑似出生于公务员/教育系统的家庭，父母其一据说为正处级。欧神是神童，跳了两级，上海高考前一百，稀里糊涂下进入复旦物理系。那是他的迷惘期，毕业后进入某五百强快消品外企做管培生。然而，他觉得那样的人生毫无希望，毫无前途，他渴望成功。尝试过做外汇，失败告终。在温相（相，古称丞相，今乃总理。我特么很讨厌现在还用相这个字，放眼世界都是民主国家的天下，我天朝人民的思维还仍旧停留在封建时代）上台后的两年内，一次偶然的机遇，他接触到了上海的房地产。一开始只是为了短期获得利差，不料却一头栽了下去。</p>
<p>之前，我的粉丝里面，有人问我欧神现在房产有多少，我估计他起码有25~30套。但是后来看到他的回忆录，他第一次短期获利后，开始大量建仓。第一次大量建仓后，房价虚高，迫于父母压力，仍然抛售了500平米的上海房产，那可是2004-2005年！欧神在网络上，我们能够找到的，最早的作品，是在天涯论坛，是发表于2004年7月31日23点的：《人民币面临巨大的贬值压力》。</p>
<p>欧神在这篇文章内断言，人民币将对外升值，对内贬值。也因此，欧神认为，只有房地产，才是人民抵抗通货膨胀、资产增值的选择。然后，他发表了大量大量经济观察的文章。基本没有看走眼的。然而，当年下面，满满的都是愤青骂街留言。此时的欧神，才26岁。同时，欧神指出，炒房，是一条竞争几乎为零、不论资质人人皆可参与、只要下功夫迟早赚出一个亿的康庄大道。看准了大趋势，然后一头扎在炒房领域。反复炒反复炒反复炒。炒房是个非常孤独的事情，炒房客蛮少，躺着赚钱也缺乏社交。欧神即便再有钱，在经济关系中，不过是个中国最牛散户，兴许还剥削Ｎ多人以收租。有钱，有闲，就在网上开论坛，聊天。他系统性地把全部炒房心得，发表出来。他目前认为京沪还有上升空间。而且，非常看好重庆。2016年11月，他在清华第一次公开亮相，为某经济论坛发表演讲。</p>
<p>这是他的大致经历了。他的女儿，如果我没记错，出生于庚寅年的己土日。2010年。他不止一个孩子了。</p>
<hr>
<p>在最新的一期水库论坛中，欧神坦言对于房产而言，普通人已经没有上车机会了，阶级固化基本完成了。这真是一个疯狂的时代。TG（T代表锤子，G代表镰刀，这是标识，只可意会，不可言传），ZF，吃相越来越难看了。他们要把一切不属于自己阶层的人，打成奴隶，永世不得翻身。就像西西弗斯一样，推着无用的巨石，永世处于那样的状态。而另一方面，那些没上车的人们，他们不比那些上车的聪明？不比他们勤奋？不比他们优秀？不比他们道德？阶级流动的渠道，说关闭就关闭。普通的屌丝阶层，甚至扩大到中产阶层，连知情权都没有，怎么回事都不知道。像苍蝇一样无头乱撞，什么都不懂，最后只能归咎自己命不好。此时此刻，我才感受到了欧神的价值。屌丝一生，都遇不到一个真正的富人，告诉他们真正的诀窍。只能自己瞎折腾一生，哪怕比欧神双商高资质好，都会如此。再聪明，八字再好，也不过是韭菜，只有被收割的命运。只不过，十年前，韭菜们还有系统性逃离的机会。人人那时，都有机会。除了90后。80后也有微弱的机会。现在当然也有，只不过阶层固化获得了决定性的胜利，看还有谁能钻过去吧。未来，八字估计都不顶用了。货币会一直超发，没有笼子的权利就是逃出瓶子的恶魔，人民控制不了货币超发，只能默默承受着通胀对你的财富的吞噬，想想七八十年代那些上一代人节衣缩食，辛苦攒下百十来块的养老钱，现在呢？也只够两顿饭钱吧？我有时会莫名地心疼这些人，钱真的攒不住，攒一辈子几年就给你通胀掉了，另一方面我又对大众的愚昧恨之入骨，他们不知道争取权利也不知道支持那些为他们争取权利的人，反而给那些为整个社会民主化进程呕心沥血的人泼以无情的冷水与嘲讽。在心里默默讥笑他们“你们这些傻叉，就知道民主就知道争取权利，看我们多聪明，躲在你们背后，你们争取到了，我们一样可以享受，你们争取不到，我还有嘲笑的对象，好爽啊”，这就是我天朝绝大多数人的心态吧。</p>
<hr>
<p>欧神对金融系统有着深刻的认知，比如央行拿外汇去拯救国有银行的坏账，好多人感觉和自己没有关系，于是没有人出声，其实一方面坏账是指钱被贪官贪污或者携款潜逃国外，导致银行无法填补亏空，形成坏账，另一方面，外汇属于全体中国人民，用外汇储备去填补亏空，本质上就是用每一个中国人辛苦攒来的钱去填补亏空，这里面包括你的、我的、他的、所有人的，没人能逃得掉。为什么说是人民的钱，因为这背后一系列的操作最后都会导致物价上涨，由物价上涨来填补，而每一个人只要你在国内生存，就间接的变成由你消费膨胀的物价来填补坏账的亏空。</p>
<p>在2004年的时候，基于对金融系统深刻的认知，欧成效说“房价是太低，不是太高，远远地太低太低太低。房价上涨，是一个《挤泡沫》的过程，挤掉的是货币系统里面的泡沫”。我补充一句，坏账越多亏空越多贪官越多，最后导致的就是人民币里面的泡沫越多，而如果仅靠物价上涨是无法消化这么多泡沫的，而且老百姓也最不愿意，因为你每天都要吃饭喝水，你无法承受这么多泡沫所带来的物价上涨，所以归根结底，一个可靠的手段是房价上涨，用房价来消化货币系统中的泡沫，进而将房价维持在高位，也将超发的货币绑定在房价之上。</p>
<p>购房千万不要购买以房型作为卖点的楼盘，否则你很可能进去了就被套牢了，房型并没有统一的标准，如果是自住，只需要选择适合你自己的就好了，无非是朝向、通风、采光。对于上班族来说，一个4~6平米的客卫，才是最优质房型。强烈推荐买房应该买市中心，五六年房龄的低估房，原则上不买一手房。</p>
<p>如果汇率上涨，则受益者是人民币持有人，也即是十万万老百姓。你可以很轻松地去加勒比海海滩度假，去希腊看奥运会，甚至娶一个年轻漂亮的买来西亚太太。而如果汇率不涨，国内通胀的话。受益的是政府和银行。作为最大的债务人，几万亿的坏账将相应缩水，从而更容易偿还。政府还将获得大量的铸币权，以应付财政开支。</p>
<p>房地产事业，是一种典型的“剥削内贸补贴外贸”。用国内老百姓的负担，来补贴出口竞争力。甚至可以说，“房价越高，出口竞争力越强”。中国也即将走上日本的老路。低汇率，导致外汇储备急剧增加，引发通胀压力。而政府将通胀压力引向房地产，让国内百姓为此买单。外贸出口也始终不受损伤。这是欧神2005年说的话，以他的话来判断2005~2017这之间中国的经济走势来说的话，基本上都是正确的。</p>
<p>欧神说房价越高，居民购买力越强，因为他认为房价就像是零和博弈，有人付出钱买房，自然就有人靠卖房获取收入，那么你想过如果卖方都是政府呢？或者说卖方都是开发商呢？这种大量的金钱集中在一个人或者一个组织的身上，其购买力是远远不如将钱分散到千万人身上的，因为一个人消费能力再强，自然也无法消费一千个人或者一万个人所消费的东西，所以我并不赞成欧神的观点。相反我认为高房价大大的透支了刚需族中产阶级的购买力，注意我说的是刚需，那些名下有几套房的中产并不在我的范围之内。</p>
<p>美元并没有什么购买力。3万亿Dollar的外汇储备，也根本买不回“中国曾出口”的等价购买力。更何况，美国的信用，已经大大受到质疑，三万亿美元最终能拿回多少。金融界目前都是个大大的问号。如果美元收不回来，那么我们过去二三十年的出口，都扔到海里了。如果美元通货膨胀，贬值2/3，那么我们过去十几年的出口都扔到海里了。出口导向型的经济政策，其最终的输家只有一个，那就是农民，因为商人出口挣到外汇，央行把外汇换成人民币，而这人民币就是靠印刷机印出来的，农民手中的钱凭空损失了购买力，而他们并不自知。有人冲到我们的草原，抢夺我们的牛马，抢夺我们的羊羔。我们拼命反抗，因为我们知道他是强盗，抢我小羊的强盗。有人在电脑前拨动了几个数字，宣布几项政策。造成了数以十万亿的财富移动，造成了沿海几亿人的繁荣，造成了内陆几亿人的贫穷，而这幕后黑手、最大的强盗其实就是央行。我们不知道，因为我们不懂经济，不懂金融学。我们只知道日子是很苦很苦的，却从来不明白为什么。</p>
<p>治大国如烹小鲜。当远方的信使，骑着快马气喘吁吁地奔波了八百里跑过来和你说“宰相大人，不好了，出大事了”。你掏出手枪，砰地一声，把信使打死了。然后洋洋得意地和周围人说：“我什么也没听到，天下太平”。你这不是2B么。我们现在的内阁团，就是这么一群2B。欧神的这段话说的非常贴切，对于房价是十年九控，除了2009年（08年金融危机，余威延后，致09年房价略降），基本上是越控越涨，很简单，现在房价的90%成本是土地成本，土地成本不降，你想降房价？开玩笑，有哪个开发商愿意亏本建房卖给你呢？房价必然是土地成本+建筑成本+利润等的总和，所以说限购限贷只会使需求延后而已，对于减少土地供应，则更是傻逼政策，未来没地建房了，你还指望房价下降？不涨上天才怪呢！</p>
<p>文章里有一个小段子，我感觉不错，摘录如下“一个中国人刚到USA时，美国人对他说：‘美国是一个法制社会，你明白吗？’。那个人说：‘明白，公民都要守法’。美国官员说：‘No，法制社会的意思是，政府要守法’”。禁不住一声仰天长叹！</p>
<p>另外一个段子是这样的，话说重庆的中心是解放碑，解放碑就是重庆中央广场的一个石碑，连接放射性的五条大道，其地位类似于上海的人民广场。段子是这么说的，当年江姐被捕，就是因为蒲志高看见她在朝天门码头上船，穿西装而且自己扛皮箱，于是蒲志高推测她必然是想省钱的G党特务兼屌丝无疑。哈哈，笑了半天。</p>
<p>在任何一个社会，任何一个时代，“觉醒”的人都是少数的，哪怕启蒙时代也不例外。具体来说，就是无论社会怎样变革，哪怕再过100年。社会上看“综艺”节目的人数，仍将大大多于《科学新发现》。阿姨们会为“中国达人秀”上两个镜头感动得热泪盈眶，却丝毫不考虑新出的法规对公平的践踏。用中国一句很有传统智慧的话说：“肉食者鄙”。对于“觉醒”的人群，估计占总人口的0.1%，以中国目前的人口规模，则是100W人。这个数字包含了中国目前所有的“上层”精英。包括所有有权有势的人。这个社会其实就是0.1%的人，在奴役着99.9%的人，从诛心的角度讲，则是0.1%的人在愚弄着99.9%的人。比如现在火遍全国的学区房，其实这些接盘侠们只能算是中产里的富裕者而已，完全算不上精英或者高层，精英和高层是不会让他的后代在国内接受这种洗脑式的垃圾教育的，他们的后代早已驰骋在国外的世界顶级名校中了。</p>
<p>如果你要买房，那么记住一句话准没错，“政府呼吁买房时，一般都是房价最低的时候，买房的事得听政府的”。听党的话跟党走，政策放松时马上入场买，涨个一年半，政府要调控了马上卖，高抛低吸，虽然不一定能卖在最顶峰，但肯定比你追涨杀跌要强百倍。</p>
<p><strong>参考文献</strong><br>[1] <a href="https://zhbjob.gitbooks.io/yevon_ou/content/" target="_blank" rel="external">欧神文集</a>（仅有部分，内容不全，全文请自行去下载PDF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;欧神简介：&lt;/strong&gt;姓欧名成效。出生于丁巳年癸丑月癸酉日。上海人，疑似出生于公务员/教育系统的家庭，父母其一据说为正处级。欧神是神童，跳了两级，上海高考前一百，稀里糊涂下进入复旦物理系。那是他的迷惘期，毕业后进入某五百强快消品外企做管培生。然而，他觉
    
    </summary>
    
      <category term="Life-Talk" scheme="http://www.codepub.cn/categories/Life-Talk/"/>
    
    
      <category term="Thinking" scheme="http://www.codepub.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>提高中文输入效率—自然双拼输入法</title>
    <link href="http://www.codepub.cn/2017/04/06/Improving-chinese-input-efficiency-natural-shuangpin-input-method/"/>
    <id>http://www.codepub.cn/2017/04/06/Improving-chinese-input-efficiency-natural-shuangpin-input-method/</id>
    <published>2017-04-06T13:19:41.000Z</published>
    <updated>2017-11-20T14:18:34.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>每个人的大脑都有其自己的舒适区，比如说从家到公司开车上班，大脑会优先选择走熟悉的路线，而不是每天变个花样走陌生的路线，所以大脑其实是有惰性的，它总是会优先选择自己最熟悉、最不费力、也最简单的策略。长此以往，如果你不主动跳出舒适区的话，大脑自己是无法成长的。这一点小马（马克·扎克伯格，不是马云爸爸哦）也已经认识到了，不得不说，牛人就是牛人，尽管衣食无忧，此生不必奋斗了，但是依然在不断进步，让自己变得更加优秀。小马自己说“每年我都要给自己设立一个挑战，去学习新的东西，让自己在工作之外得到成长”。所以他特别为自己制定了每一年的挑战计划，列表如下：</p>
<ul>
<li>2009年挑战每天戴领带上班</li>
<li>2010年挑战学习汉语</li>
<li>2011年挑战只吃自己亲手屠宰的动物</li>
<li>2012年挑战每天写代码</li>
<li>2013年挑战每天跟除脸书员工之外的不同的人见面</li>
<li>2014年挑战每天写封感谢信</li>
<li>2015年挑战每个月读两本书</li>
<li>2016年挑战开发一款私人专属人工智能助手以及全年跑步587公里（365英里）</li>
<li>2017年挑战走遍美国每一个州，听取民众的声音</li>
</ul>
<p>成功的人不可怕，可怕的是成功以后还不断努力的人，比如小马，所以我们应该无条件的向优秀的人学习。为此，我也开始学习一项可能大多数人一辈子都不会学习的技能，那就是双拼输入法。为什么选择双拼呢？因为大多数人用的都是全拼，切换输入法的成本其实是很高的，而双拼效率要胜过全拼，粗略比较一下双方的击键次数，滕王阁序863字。用全拼的字符数（不计空格）2387个。用双拼的字符数是1580个。双拼的字符数是全拼的66%左右。使用辅助码后，双拼的重码差不多是10%到20%，常用的语境中，可以实现盲打。</p>
<h3 id="双拼方案"><a href="#双拼方案" class="headerlink" title="双拼方案"></a>双拼方案</h3><p>双拼的详细信息参看<a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC" target="_blank" rel="external">双拼-维基百科</a>，流行的双拼方案有</p>
<ul>
<li>自然码双拼</li>
<li>小鹤双拼</li>
<li>拼音加加双拼</li>
<li>微软拼音2003双拼</li>
<li>紫光拼音双拼</li>
<li>智能ABC双拼</li>
</ul>
<p>我选择的是自然双拼方案，主要是因为这是目前最流行最通用的双拼方案，很多输入法软件的默认双拼方案就是自然码。不过据说小鹤双拼的方案用起来最舒服，如果不介意的话，那么选择应用最广泛的自然码双拼方案即可。</p>
<h3 id="自然双拼"><a href="#自然双拼" class="headerlink" title="自然双拼"></a>自然双拼</h3><p>自然双拼是有官网的，不过比较丑陋而已，<a href="http://www.zrm.com.cn/" target="_blank" rel="external">官网点我</a>。根据官网自然码简介如下</p>
<ul>
<li>自然码是一款非常成熟且定位在高端用户群的输入法，具有超强的整句错误定位和修正功能，兼容非常多的操作习惯，可选择各种扩充专业词库，并可挂接黑马整句输入引擎（偏重医学方面）</li>
<li>自然码利用压缩韵母和偏旁部首发音，以拼音为基础的高效编码方案。在非常简单的情况下，达到了远远超过普通拼音的最佳境界。自然码双拼部分已经是目前事实上的标准方案，广泛用于各种输入法中，其中与自然码非常相似的微软双拼也是自然码授权的修改版</li>
<li>自然码方案的理念是让用户只要记住20多个压缩韵母就能快速准确输入。免除全拼记忆汉字和词组顺序、记忆大量简码，输入速度上不去的麻烦。让用户在使用中轻松自然，随心所欲</li>
</ul>
<p>在全拼中，每个字都需要声母和韵母组成，但声母和韵母所需要输入的字母个数是不一定的，从一个到三个不等，按键时就需要进行多次输入才能组成一个声母或韵母。而双拼对其进行规范化，无论是声母还是韵母，都各自集合在一个按键上，即把声母中<code>zh</code>、<code>ch</code>、<code>sh</code>和非单字母韵母（<code>ong</code>、<code>iong</code>、<code>uang</code>等）进行重新编排，使每个声母或者韵母都对应一个按键。</p>
<p>这样一来双拼相对于全拼的简便则凸显出来，特别是对于<code>an</code>、<code>ao</code>、<code>un</code>、<code>ang</code>、<code>ong</code>、<code>ing</code>、<code>uang</code>、<code>iang</code>等这些长的拼音组合以及单字输入这种需求来说，比如说<code>「量」</code>全拼用<code>liang</code>，双拼只需要<code>LL</code>，两个键。</p>
<p>以自然双拼的键位设置为例，如果我想输入「少数派」三个字，其键盘上：</p>
<ul>
<li>按键「U」对应的声母「sh」，对应韵母「u」</li>
<li>按键「K」对应的声母「k」，对应韵母「ao」</li>
<li>按键「P」对应的声母「p」，对应的韵母「un/ün」</li>
<li>按键「L」对应的声母「l」，对应的韵母「ai」</li>
</ul>
<p>那么，输入「少数派」就变得很简单了：</p>
<ul>
<li>敲击「U」「K」，就能输入「sh」「ao」</li>
<li>敲击「U」「U」，就能输入「sh」「u」</li>
<li>敲击「P」「L」，就能输入「p」「ai」</li>
</ul>
<p>所以只需要打印一份自然双拼键位图放在身旁即可，照着键位图练习一段时间基本上就可以记住全部键位了，实现超快盲打。</p>
<h3 id="终极总结"><a href="#终极总结" class="headerlink" title="终极总结"></a>终极总结</h3><p>按照笔者自己的经历，学习双拼大概经历<strong>四个阶段：</strong></p>
<ul>
<li>用双拼是不是傻。</li>
<li>好想念用全拼时快捷如风的日子。</li>
<li>敲键盘好有感觉而且速度还不错唉。</li>
<li>用全拼是不是傻。</li>
</ul>
<p>当许多年以后，来到一个陌生的电脑前，看见他们星移电掣地在键盘前忙碌地来回敲打，不时还冲你莞尔一笑：「我打字快伐？」，这时你只是报之神秘的一笑，视而不语，让笑意消散在风中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h3&gt;&lt;p&gt;每个人的大脑都有其自己的舒适区，比如说从家到公司开车上班，大脑会优先选择走熟悉的路线，而不是每天变个花样走陌生的路线，所以大脑其实是有惰性的
    
    </summary>
    
      <category term="Skill" scheme="http://www.codepub.cn/categories/Skill/"/>
    
    
      <category term="Input Method" scheme="http://www.codepub.cn/tags/Input-Method/"/>
    
  </entry>
  
</feed>
